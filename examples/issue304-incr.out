#############
# Desugared #
#############

mutual {
  constructor Nat : Type.
  
  constructor Z : Nat.
  
  constructor S : (_ : Nat) -> Nat.
}

mutual {
  constructor Fin : (_ : Nat) -> Type.
  
  constructor FZ : (n :I Nat) -> Fin (S n).
  
  constructor FS : (n :I Nat) -> (_ : Fin n) -> Fin (S n).
}

mutual {
  constructor Vect : (_ : Nat) -> (_ : Type) -> Type.
  
  constructor Nil : (a :I Type) -> Vect Z a.
  
  constructor Cons : (a :I Type) -> (n :I Nat) -> (_ : a) -> (_ : Vect n a) -> Vect (S n) a.
}

mutual {
  constructor Elem : (a : Type) -> (n : Nat) -> (_ : a) -> (_ : Vect n a) -> Type.
  
  constructor Here : (a :I Type) -> (n :I Nat) -> (x : a) -> (xs : Vect n a) -> Elem a (S n) x (Cons a n x xs).
  
  constructor There : (a :I Type) -> (n :I Nat) -> (x : a) -> (y : a) -> (xs : Vect n a) -> (t : Elem a n x xs) -> Elem a (S n) x (Cons a n y xs).
}

mutual {
  constructor Typ : Type.
  
  constructor TLam : (_ : Typ) -> (_ : Typ) -> Typ.
  
  constructor TNat : Typ.
}

mutual {
  constructor Term : (n : Nat) -> (_ : Typ) -> (_ : Vect n Typ) -> Type.
  
  constructor Var : (a : Typ) -> (n : Nat) -> (ctx : Vect n Typ) -> (_ : Elem Typ n a ctx) -> Term n a ctx.
  
  constructor Lam : (a : Typ) -> (n : Nat) -> (ctx : Vect n Typ) -> (b : Typ) -> (_ : Term (S n) b (Cons Typ n a ctx)) -> Term n (TLam a b) ctx.
  
  constructor Fix : (a : Typ) -> (n : Nat) -> (ctx : Vect n Typ) -> (_ : Term (S n) a (Cons Typ n a ctx)) -> Term n a ctx.
}

lookup : (n : Nat) -> (_ : Vect n Typ) -> (_ : Fin n) -> Typ {
  forall (a : Typ) (n : Nat) (ctx : Vect n Typ)
  lookup ({S} n) ({Cons} [Typ] [n] a ctx) (FZ [n]) ~> a
  
  forall (a : Typ) (n : Nat) (ctx : Vect n Typ) (i : Fin n)
  lookup ({S} n) ({Cons} [Typ] [n] a ctx) (FS [n] i) ~> lookup n ctx i
}

count : (n : Nat) -> (ctx : Vect n Typ) -> (i : Fin n) -> Elem Typ n (lookup n ctx i) ctx {
  forall (n : Nat) (ctx : Vect n Typ) (a : Typ)
  count ({S} n) ({Cons} [Typ] [n] a ctx) (FZ [n]) ~> Here Typ n a ctx
  
  forall (n : Nat) (ctx : Vect n Typ) (a : Typ) (i : Fin n)
  count ({S} n) ({Cons} [Typ] [n] a ctx) (FS [n] i) ~> There Typ n (lookup n ctx i) a ctx (count n ctx i)
}

main : Type {
  main  ~> Type
}
#############
# Evarified #
#############

mutual {
  constructor Nat :59 Type.
  
  constructor Z :97 Nat.
  
  constructor S :63 (_ :L Nat) -> Nat.
}

mutual {
  constructor Fin :16 (_ :L Nat) -> Type.
  
  constructor FZ :13 (n :I Nat) -> Fin (S n).
  
  constructor FS :9 (n :I Nat) -> (_ :L Fin n) -> Fin (S n).
}

mutual {
  constructor Vect :96 (_ :L Nat) -> (_ :L Type) -> Type.
  
  constructor Nil :60 (a :I Type) -> Vect Z a.
  
  constructor Cons :0 (a :I Type) -> (n :I Nat) -> (_ :L a) -> (_ :L Vect n a) -> Vect (S n) a.
}

mutual {
  constructor Elem :6 (a :L Type) -> (n :L Nat) -> (_ :L a) -> (_ :L Vect n a) -> Type.
  
  constructor Here :31 (a :I Type) -> (n :I Nat) -> (x :L a) -> (xs :L Vect n a) -> Elem a (S n) x (Cons a n x xs).
  
  constructor There :69 (a :I Type) -> (n :I Nat) -> (x :L a) -> (y :L a) -> (xs :L Vect n a) -> (t :L Elem a n x xs) -> Elem a (S n) x (Cons a n y xs).
}

mutual {
  constructor Typ :85 Type.
  
  constructor TLam :64 (_ :L Typ) -> (_ :L Typ) -> Typ.
  
  constructor TNat :65 Typ.
}

mutual {
  constructor Term :66 (n :L Nat) -> (_ :L Typ) -> (_ :L Vect n Typ) -> Type.
  
  constructor Var :86 (a :L Typ) -> (n :L Nat) -> (ctx :L Vect n Typ) -> (_ :L Elem Typ n a ctx) -> Term n a ctx.
  
  constructor Lam :43 (a :L Typ) -> (n :L Nat) -> (ctx :L Vect n Typ) -> (b :L Typ) -> (_ :L Term (S n) b (Cons Typ n a ctx)) -> Term n (TLam a b) ctx.
  
  constructor Fix :17 (a :L Typ) -> (n :L Nat) -> (ctx :L Vect n Typ) -> (_ :L Term (S n) a (Cons Typ n a ctx)) -> Term n a ctx.
}

lookup :159 (n :160 Nat) -> (_ :161 Vect n Typ) -> (_ :164 Fin n) -> Typ {
  forall (a :170 Typ) (n :169 Nat) (ctx :166 Vect n Typ)
  lookup ({S} n) ({Cons} [Typ] [n] a ctx) (FZ [n]) ~> a
  
  forall (a :186 Typ) (n :185 Nat) (ctx :182 Vect n Typ) (i :180 Fin n)
  lookup ({S} n) ({Cons} [Typ] [n] a ctx) (FS [n] i) ~> lookup n ctx i
}

count :98 (n :99 Nat) -> (ctx :100 Vect n Typ) -> (i :103 Fin n) -> Elem Typ n (lookup n ctx i) ctx {
  forall (n :116 Nat) (ctx :113 Vect n Typ) (a :112 Typ)
  count ({S} n) ({Cons} [Typ] [n] a ctx) (FZ [n]) ~> Here Typ n a ctx
  
  forall (n :136 Nat) (ctx :133 Vect n Typ) (a :132 Typ) (i :130 Fin n)
  count ({S} n) ({Cons} [Typ] [n] a ctx) (FS [n] i) ~> There Typ n (lookup n ctx i) a ctx (count n ctx i)
}

main :200 Type {
  main  ~> Type
}
Running erasure inference...

########################
# Inferred constraints #
########################

31 ≥ sum
  product [98]
69 ≥ sum
  product [98]
85 ≥ sum
  product [98, I]
  product [98, I]
98 ≥ sum
  product [98, L]
159 ≥ sum
  product [159]
  product [98, L]
200 ≥ sum
  product []
L ~ 14
L ~ 15
L ~ 10
L ~ 11
L ~ 12
L ~ 62
L ~ 61
L ~ 2
L ~ 1
L ~ 4
L ~ 5
L ~ 3
L ~ 8
L ~ 7
L ~ 33
L ~ 32
L ~ 37
L ~ 36
L ~ 38
L ~ 35
L ~ 34
I ~ 42
I ~ 41
L ~ 40
L ~ 39
1 ~ 32
2 ~ 33
7 ~ 3
8 ~ 4
L ~ 71
L ~ 70
L ~ 75
L ~ 74
L ~ 73
L ~ 72
7 ~ 70
8 ~ 71
L ~ 79
L ~ 78
L ~ 80
L ~ 77
L ~ 76
I ~ 84
I ~ 83
L ~ 82
L ~ 81
1 ~ 70
2 ~ 71
7 ~ 3
8 ~ 4
L ~ 68
L ~ 67
L ~ 88
L ~ 87
L ~ 92
L ~ 91
L ~ 90
L ~ 89
7 ~ 87
8 ~ 88
L ~ 95
L ~ 94
L ~ 93
67 ~ 87
68 ~ 88
L ~ 45
L ~ 44
L ~ 48
L ~ 49
L ~ 47
L ~ 46
I ~ 53
I ~ 52
L ~ 51
L ~ 50
1 ~ 44
2 ~ 45
67 ~ 3
68 ~ 4
L ~ 56
L ~ 55
L ~ 58
L ~ 57
L ~ 54
67 ~ 44
68 ~ 45
L ~ 19
L ~ 18
L ~ 22
L ~ 23
L ~ 21
L ~ 20
I ~ 27
I ~ 26
L ~ 25
L ~ 24
1 ~ 18
2 ~ 19
67 ~ 3
68 ~ 4
L ~ 30
L ~ 29
L ~ 28
67 ~ 18
68 ~ 19
L ~ 163
L ~ 162
L ~ 165
L ~ 168
L ~ 167
170 ~ product [L, 161]
169 ~ product [L, 160]
166 ~ product [L, 161]
160 ~ 171
product [160] ≥ sum
  product [I]
L ~ 172
161 ~ 173
product [161] ≥ sum
  product [I]
I ~ 174
I ~ 175
L ~ 176
L ~ 177
1 ~ 167
2 ~ 168
162 ~ 3
163 ~ 4
164 ~ 178
product [164] ≥ sum
  product [L]
I ~ 179
165 ~ 14
170 ≥ sum
  product []
169 ≥ sum
166 ≥ sum
L ~ 184
L ~ 183
L ~ 181
186 ~ product [L, 161]
185 ~ product [L, 160]
182 ~ product [L, 161]
180 ~ product [L, 164]
160 ~ 187
product [160] ≥ sum
  product [I]
L ~ 188
161 ~ 189
product [161] ≥ sum
  product [I]
I ~ 190
I ~ 191
L ~ 192
L ~ 193
1 ~ 183
2 ~ 184
162 ~ 3
163 ~ 4
164 ~ 194
product [164] ≥ sum
  product [L]
I ~ 195
L ~ 196
10 ~ 181
165 ~ 11
186 ≥ sum
185 ≥ sum
  product [160]
182 ≥ sum
  product [161]
180 ≥ sum
  product [164]
160 ~ 199
161 ~ 198
162 ~ 183
163 ~ 184
164 ~ 197
165 ~ 181
L ~ 102
L ~ 101
L ~ 104
L ~ 108
L ~ 107
L ~ 106
160 ~ 111
161 ~ 110
162 ~ 101
163 ~ 102
164 ~ 109
165 ~ 104
L ~ 105
7 ~ 101
8 ~ 102
L ~ 115
L ~ 114
116 ~ product [L, 99]
113 ~ product [L, 100]
112 ~ product [L, 100]
99 ~ 117
product [99] ≥ sum
  product [I]
L ~ 118
100 ~ 119
product [100] ≥ sum
  product [I]
I ~ 120
I ~ 121
L ~ 122
L ~ 123
1 ~ 114
2 ~ 115
101 ~ 3
102 ~ 4
103 ~ 124
product [103] ≥ sum
  product [L]
I ~ 125
104 ~ 14
116 ≥ sum
  product [I]
113 ≥ sum
  product [L]
112 ≥ sum
  product [L]
I ~ 129
I ~ 128
L ~ 127
L ~ 126
32 ~ 114
33 ~ 115
34 ~ 105
35 ~ 106
36 ~ 107
37 ~ 108
L ~ 135
L ~ 134
L ~ 131
136 ~ product [L, 99]
133 ~ product [L, 100]
132 ~ product [L, 100]
130 ~ product [L, 103]
99 ~ 137
product [99] ≥ sum
  product [I]
L ~ 138
100 ~ 139
product [100] ≥ sum
  product [I]
I ~ 140
I ~ 141
L ~ 142
L ~ 143
1 ~ 134
2 ~ 135
101 ~ 3
102 ~ 4
103 ~ 144
product [103] ≥ sum
  product [L]
I ~ 145
L ~ 146
10 ~ 131
104 ~ 11
136 ≥ sum
  product [I]
  product [160, L]
  product [99, L]
133 ≥ sum
  product [161, L]
  product [L]
  product [100, L]
132 ≥ sum
  product [L]
130 ≥ sum
  product [164, L]
  product [103, L]
I ~ 152
I ~ 151
L ~ 150
160 ~ 155
161 ~ 154
162 ~ 134
163 ~ 135
164 ~ 153
165 ~ 131
L ~ 149
L ~ 148
70 ~ 134
71 ~ 135
L ~ 147
99 ~ 158
100 ~ 157
101 ~ 134
102 ~ 135
103 ~ 156
104 ~ 131
72 ~ 105
73 ~ 106
74 ~ 107
75 ~ 108
76 ~ 105
77 ~ 106
78 ~ 107
79 ~ 108
#######################
# Deferred equalities #
#######################

4 -> S n ~ S n
4 -> S n ~ S n
4 -> S n ~ S n
4 -> S n ~ S n
4 -> S n ~ S n
14 -> S n ~ S n
4 -> S n ~ S n
11 -> S n ~ S n
4 -> S n ~ S n
14 -> S n ~ S n
107 -> S n ~ S n
106 -> lookup (S n) (Cons Typ n a ctx) (FZ n) ~ a
105 -> Cons Typ n a ctx ~ Cons Typ n a ctx
4 -> S n ~ S n
11 -> S n ~ S n
106 -> lookup n ctx i ~ lookup n ctx i
107 -> S n ~ S n
106 -> lookup (S n) (Cons Typ n a ctx) (FS n i) ~ lookup n ctx i
105 -> Cons Typ n a ctx ~ Cons Typ n a ctx

#####################
# Variance of evars #
#####################

covariant: []
contravariant: [99, 100, 103, 160, 161, 164]
  -> iteration 1
    S n ~ S n
    S n ~ S n
    S n ~ S n
    S n ~ S n
    S n ~ S n
    S n ~ S n
    S n ~ S n
    S n ~ S n
    S n ~ S n
    S n ~ S n
    S n ~ S n
    lookup (S n) (Cons Typ n a ctx) (FZ n) ~ a
    Cons Typ n a ctx ~ Cons Typ n a ctx
    S n ~ S n
    S n ~ S n
    lookup n ctx i ~ lookup n ctx i
    S n ~ S n
    lookup (S n) (Cons Typ n a ctx) (FS n i) ~ lookup n ctx i
    Cons Typ n a ctx ~ Cons Typ n a ctx

###################
# Final valuation #
###################

  1 -> L
  2 -> L
  3 -> L
  4 -> L
  5 -> L
  7 -> L
  8 -> L
  10 -> L
  11 -> L
  12 -> L
  14 -> L
  15 -> L
  18 -> L
  19 -> L
  20 -> L
  21 -> L
  22 -> L
  23 -> L
  24 -> L
  25 -> L
  26 -> I
  27 -> I
  28 -> L
  29 -> L
  30 -> L
  31 -> I
  32 -> L
  33 -> L
  34 -> L
  35 -> L
  36 -> L
  37 -> L
  38 -> L
  39 -> L
  40 -> L
  41 -> I
  42 -> I
  44 -> L
  45 -> L
  46 -> L
  47 -> L
  48 -> L
  49 -> L
  50 -> L
  51 -> L
  52 -> I
  53 -> I
  54 -> L
  55 -> L
  56 -> L
  57 -> L
  58 -> L
  61 -> L
  62 -> L
  67 -> L
  68 -> L
  69 -> I
  70 -> L
  71 -> L
  72 -> L
  73 -> L
  74 -> L
  75 -> L
  76 -> L
  77 -> L
  78 -> L
  79 -> L
  80 -> L
  81 -> L
  82 -> L
  83 -> I
  84 -> I
  85 -> I
  87 -> L
  88 -> L
  89 -> L
  90 -> L
  91 -> L
  92 -> L
  93 -> L
  94 -> L
  95 -> L
  98 -> I
  99 -> I
  100 -> R
  101 -> L
  102 -> L
  103 -> R
  104 -> L
  105 -> L
  106 -> L
  107 -> L
  108 -> L
  109 -> R
  110 -> R
  111 -> I
  112 -> R
  113 -> R
  114 -> L
  115 -> L
  116 -> I
  117 -> I
  118 -> L
  119 -> R
  120 -> I
  121 -> I
  122 -> L
  123 -> L
  124 -> R
  125 -> I
  126 -> L
  127 -> L
  128 -> I
  129 -> I
  130 -> R
  131 -> L
  132 -> R
  133 -> R
  134 -> L
  135 -> L
  136 -> I
  137 -> I
  138 -> L
  139 -> R
  140 -> I
  141 -> I
  142 -> L
  143 -> L
  144 -> R
  145 -> I
  146 -> L
  147 -> L
  148 -> L
  149 -> L
  150 -> L
  151 -> I
  152 -> I
  153 -> R
  154 -> R
  155 -> I
  156 -> R
  157 -> R
  158 -> I
  159 -> I
  160 -> I
  161 -> R
  162 -> L
  163 -> L
  164 -> R
  165 -> L
  166 -> R
  167 -> L
  168 -> L
  169 -> I
  170 -> R
  171 -> I
  172 -> L
  173 -> R
  174 -> I
  175 -> I
  176 -> L
  177 -> L
  178 -> R
  179 -> I
  180 -> R
  181 -> L
  182 -> R
  183 -> L
  184 -> L
  185 -> I
  186 -> R
  187 -> I
  188 -> L
  189 -> R
  190 -> I
  191 -> I
  192 -> L
  193 -> L
  194 -> R
  195 -> I
  196 -> L
  197 -> R
  198 -> R
  199 -> I
  200 -> L

#####################
# Annotated program #
#####################

mutual {
  constructor Nat :I Type.
  
  constructor Z :I Nat.
  
  constructor S :I (_ :L Nat) -> Nat.
}

mutual {
  constructor Fin :I (_ :L Nat) -> Type.
  
  constructor FZ :I (n :I Nat) -> Fin (S n).
  
  constructor FS :I (n :I Nat) -> (_ :L Fin n) -> Fin (S n).
}

mutual {
  constructor Vect :I (_ :L Nat) -> (_ :L Type) -> Type.
  
  constructor Nil :I (a :I Type) -> Vect Z a.
  
  constructor Cons :I (a :I Type) -> (n :I Nat) -> (_ :L a) -> (_ :L Vect n a) -> Vect (S n) a.
}

mutual {
  constructor Elem :I (a :L Type) -> (n :L Nat) -> (_ :L a) -> (_ :L Vect n a) -> Type.
  
  constructor Here :I (a :I Type) -> (n :I Nat) -> (x :L a) -> (xs :L Vect n a) -> Elem a (S n) x (Cons a n x xs).
  
  constructor There :I (a :I Type) -> (n :I Nat) -> (x :L a) -> (y :L a) -> (xs :L Vect n a) -> (t :L Elem a n x xs) -> Elem a (S n) x (Cons a n y xs).
}

mutual {
  constructor Typ :I Type.
  
  constructor TLam :I (_ :L Typ) -> (_ :L Typ) -> Typ.
  
  constructor TNat :I Typ.
}

mutual {
  constructor Term :I (n :L Nat) -> (_ :L Typ) -> (_ :L Vect n Typ) -> Type.
  
  constructor Var :I (a :L Typ) -> (n :L Nat) -> (ctx :L Vect n Typ) -> (_ :L Elem Typ n a ctx) -> Term n a ctx.
  
  constructor Lam :I (a :L Typ) -> (n :L Nat) -> (ctx :L Vect n Typ) -> (b :L Typ) -> (_ :L Term (S n) b (Cons Typ n a ctx)) -> Term n (TLam a b) ctx.
  
  constructor Fix :I (a :L Typ) -> (n :L Nat) -> (ctx :L Vect n Typ) -> (_ :L Term (S n) a (Cons Typ n a ctx)) -> Term n a ctx.
}

lookup :I (n :I Nat) -> (_ :R Vect n Typ) -> (_ :R Fin n) -> Typ {
  forall (a :R Typ) (n :I Nat) (ctx :R Vect n Typ)
  lookup ({S} n) ({Cons} [Typ] [n] a ctx) (FZ [n]) ~> a
  
  forall (a :R Typ) (n :I Nat) (ctx :R Vect n Typ) (i :R Fin n)
  lookup ({S} n) ({Cons} [Typ] [n] a ctx) (FS [n] i) ~> lookup n ctx i
}

count :I (n :I Nat) -> (ctx :R Vect n Typ) -> (i :R Fin n) -> Elem Typ n (lookup n ctx i) ctx {
  forall (n :I Nat) (ctx :R Vect n Typ) (a :R Typ)
  count ({S} n) ({Cons} [Typ] [n] a ctx) (FZ [n]) ~> Here Typ n a ctx
  
  forall (n :I Nat) (ctx :R Vect n Typ) (a :R Typ) (i :R Fin n)
  count ({S} n) ({Cons} [Typ] [n] a ctx) (FS [n] i) ~> There Typ n (lookup n ctx i) a ctx (count n ctx i)
}

main :L Type {
  main  ~> Type
}
##########
# Erased #
##########

main {
  main  ~> Type
}
################
# NF of `main` #
################

Unerased, reduced:
Type

Erased, reduced:
Type
