
#############
# Desugared #
#############

mutual {
  constructor/0 Bool : Type.
  
  constructor/0 True : Bool.
  
  constructor/0 False : Bool.
}

mutual {
  constructor/0 Nat : Type.
  
  constructor/0 Z : Nat.
  
  constructor/1 S : (n : Nat) -> Nat.
}

mutual {
  constructor/1 Vect : (_ : Nat) -> Type.
  
  constructor/0 Nil : Vect Z.
  
  constructor/3 Cons : (n :I Nat) -> (_ : Bool) -> (_ : Vect n) -> Vect (S n).
}

length : (n : Nat) -> (_ : Vect n) -> Nat {
  length {Z} Nil ~> Z
  
  forall (n : Nat) (x : Bool) (xs : Vect n).
  length ({S} n) (Cons [n] x xs) ~> S (length n xs)
}

main : Nat {
  main  ~> length (S Z) (Cons Z True Nil)
}

###############
# Elaboration #
###############

mutual {
  constructor/0 Bool : Type.
  
  constructor/0 True : Bool.
  
  constructor/0 False : Bool.
}

mutual {
  constructor/0 Nat : Type.
  
  constructor/0 Z : Nat.
  
  constructor/1 S : (n : Nat) -> Nat.
}

mutual {
  constructor/1 Vect : (_ : Nat) -> Type.
  
  constructor/0 Nil : Vect Z.
  
  constructor/3 Cons : (n :I Nat) -> (_ : Bool) -> (_ : Vect n) -> Vect (S n).
}

length : (n : Nat) -> (_ : Vect n) -> Nat {
  length {Z} Nil ~> Z
  
  forall (n : Nat) (x : Bool) (xs : Vect n).
  length ({S} n) (Cons [n] x xs) ~> S (length n xs)
}

main : Nat {
  main  ~> length (S Z) (Cons Z True Nil)
}

Equalities:


Solved metas: []

##############
# Elaborated #
##############

mutual {
  constructor/0 Bool : Type.
  
  constructor/0 True : Bool.
  
  constructor/0 False : Bool.
}

mutual {
  constructor/0 Nat : Type.
  
  constructor/0 Z : Nat.
  
  constructor/1 S : (n : Nat) -> Nat.
}

mutual {
  constructor/1 Vect : (_ : Nat) -> Type.
  
  constructor/0 Nil : Vect Z.
  
  constructor/3 Cons : (n :I Nat) -> (_ : Bool) -> (_ : Vect n) -> Vect (S n).
}

length : (n : Nat) -> (_ : Vect n) -> Nat {
  length {Z} Nil ~> Z
  
  forall (n : Nat) (x : Bool) (xs : Vect n).
  length ({S} n) (Cons [n] x xs) ~> S (length n xs)
}

main : Nat {
  main  ~> length (S Z) (Cons Z True Nil)
}

#############
# Evarified #
#############

mutual {
  constructor/0 Bool :0 Type.
  
  constructor/0 True :13 Bool.
  
  constructor/0 False :7 Bool.
}

mutual {
  constructor/0 Nat :8 Type.
  
  constructor/0 Z :16 Nat.
  
  constructor/1 S :11 (n :12 Nat) -> Nat.
}

mutual {
  constructor/1 Vect :14 (_ :15 Nat) -> Type.
  
  constructor/0 Nil :9 Vect Z.
  
  constructor/3 Cons :1 (n :I Nat) -> (_ :2 Bool) -> (_ :3 Vect n) -> Vect (S n).
}

length :17 (n :18 Nat) -> (_ :19 Vect n) -> Nat {
  length {Z} Nil ~> Z
  
  forall (n :26 Nat) (x :25 Bool) (xs :23 Vect n).
  length ({S} n) (Cons [n] x xs) ~> S (length n xs)
}

main :36 Nat {
  main  ~> length (S Z) (Cons Z True Nil)
}
inferring  mutual {
    constructor/0 Bool :0 Type.
    
    constructor/0 True :13 Bool.
    
    constructor/0 False :7 Bool.
  }

  
  
  variance of evars:
    covariant: []
    contravariant: []
  mutual {
    constructor/0 Bool :I Type.
    
    constructor/0 True :I Bool.
    
    constructor/0 False :I Bool.
  }

inferring  mutual {
    constructor/0 Nat :8 Type.
    
    constructor/0 Z :16 Nat.
    
    constructor/1 S :11 (n :12 Nat) -> Nat.
  }

  
  
  variance of evars:
    covariant: []
    contravariant: [12]
  mutual {
    constructor/0 Nat :I Type.
    
    constructor/0 Z :I Nat.
    
    constructor/1 S :I (n :I Nat) -> Nat.
  }

inferring  mutual {
    constructor/1 Vect :14 (_ :15 Nat) -> Type.
    
    constructor/0 Nil :9 Vect Z.
    
    constructor/3 Cons :1 (n :I Nat) -> (_ :2 Bool) -> (_ :3 Vect n) -> Vect (S n).
  }

  inferred constraints: 
    15 ~ 10
    15 ~ 4
    15 ~ 5
    I ~ 6
  
  
  variance of evars:
    covariant: []
    contravariant: [2, 3, 15]
  mutual {
    constructor/1 Vect :I (_ :I Nat) -> Type.
    
    constructor/0 Nil :I Vect Z.
    
    constructor/3 Cons :I (n :I Nat) -> (_ :I Bool) -> (_ :I Vect n) -> Vect (S n).
  }

inferring  length :17 (n :18 Nat) -> (_ :19 Vect n) -> Nat {
    length {Z} Nil ~> Z
    
    forall (n :26 Nat) (x :25 Bool) (xs :23 Vect n).
    length ({S} n) (Cons [n] x xs) ~> S (length n xs)
  }

  inferred constraints: 
    I ~ 20
    18 ~ 21
    product [18] ≥ sum
      product [I]
    19 ~ 22
    product [19] ≥ sum
      product [L]
    20 ~ I
    I ~ 24
    26 ~ product [I, 18]
    25 ~ product [I, 19]
    23 ~ product [I, 19]
    18 ~ 27
    product [18] ≥ sum
      product [I]
    I ~ 28
    19 ~ 29
    product [19] ≥ sum
      product [L]
    I ~ 30
    I ~ 31
    I ~ 32
    I ~ 24
    20 ~ I
    26 ≥ sum
      product [18, I]
    25 ≥ sum
    23 ≥ sum
      product [19, I]
    I ~ 33
    18 ~ 35
    19 ~ 34
    20 ~ 24
  
  
  variance of evars:
    covariant: []
    contravariant: [18, 19]
  length :I (n :I Nat) -> (_ :L Vect n) -> Nat {
    length {Z} Nil ~> Z
    
    forall (n :I Nat) (x :I Bool) (xs :I Vect n).
    length ({S} n) (Cons [n] x xs) ~> S (length n xs)
  }

inferring  main :36 Nat {
    main  ~> length (S Z) (Cons Z True Nil)
  }

  inferred constraints: 
    I ~ 38
    I ~ 39
    L ~ 37
    I ~ 42
    I ~ 41
    I ~ 40
  
  
  variance of evars:
    covariant: []
    contravariant: []
  main :I Nat {
    main  ~> length (S Z) (Cons Z True Nil)
  }


###################
# Final valuation #
###################

  0 -> I
  1 -> L
  2 -> I
  3 -> I
  4 -> I
  5 -> I
  6 -> I
  7 -> I
  8 -> I
  9 -> I
  10 -> I
  11 -> L
  12 -> I
  13 -> I
  14 -> I
  15 -> I
  16 -> L
  17 -> L
  18 -> I
  19 -> L
  20 -> I
  21 -> I
  22 -> L
  23 -> I
  24 -> I
  25 -> I
  26 -> I
  27 -> I
  28 -> I
  29 -> L
  30 -> I
  31 -> I
  32 -> I
  33 -> I
  34 -> L
  35 -> I
  36 -> L
  37 -> L
  38 -> I
  39 -> I
  40 -> I
  41 -> I
  42 -> I


#####################
# Annotated program #
#####################

mutual {
  constructor/0 Bool :I Type.
  
  constructor/0 True :I Bool.
  
  constructor/0 False :I Bool.
}

mutual {
  constructor/0 Nat :I Type.
  
  constructor/0 Z :L Nat.
  
  constructor/1 S :L (n :I Nat) -> Nat.
}

mutual {
  constructor/1 Vect :I (_ :I Nat) -> Type.
  
  constructor/0 Nil :I Vect Z.
  
  constructor/3 Cons :L (n :I Nat) -> (_ :I Bool) -> (_ :I Vect n) -> Vect (S n).
}

length :L (n :I Nat) -> (_ :L Vect n) -> Nat {
  length {Z} Nil ~> Z
  
  forall (n :I Nat) (x :I Bool) (xs :I Vect n).
  length ({S} n) (Cons [n] x xs) ~> S (length n xs)
}

main :L Nat {
  main  ~> length (S Z) (Cons Z True Nil)
}

##########
# Erased #
##########

mutual {
  constructor/0 Z.
  
  constructor/0 S.
}

constructor/0 Cons.

length {
  length Nil ~> Z
  
  length Cons ~> S
}

main {
  main  ~> length Cons
}

################
# NF of `main` #
################

Unerased, reduced:
S Z

Erased, reduced:
S
