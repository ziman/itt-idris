#############
# Desugared #
#############

mutual {
  constructor/0 N : Type.
  
  constructor/0 Z : N.
  
  constructor/1 S : (_ : N) -> N.
}

mutual {
  constructor/0 B : Type.
  
  constructor/0 T : B.
  
  constructor/0 F : B.
}

mutual {
  constructor/0 List : Type.
  
  constructor/2 Cons : (_ : B) -> (_ : List) -> List.
  
  constructor/0 Nil : List.
}

mutual {
  constructor/1 Maybe : (_ : Type) -> Type.
  
  constructor/1 Nothing : (a :I Type) -> Maybe a.
  
  constructor/2 Just : (a :I Type) -> (x : a) -> Maybe a.
}

not : (_ : B) -> B {
  not T ~> F
  
  not F ~> T
}

mutual {
  constructor/3 Id : (a : Type) -> (x : a) -> (y : a) -> Type.
  
  constructor/2 Refl : (a :I Type) -> (x :I a) -> Id a x x.
}

id : (a : Type) -> (_ : a) -> a {
  id  ~> \a : Type.
      \x : a.
        x
}

subst : (a : Type) -> (P : (_ : a) -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (w : P x) -> P y {
  forall (a : Type) (P : (x :E a) -> Type) (x : a)
  subst a P x [x] ({Refl} [a] [x]) ~> \w : P x.
      w
}

cong : (a : Type) -> (b : Type) -> (f : (x :L a) -> b) -> (x : a) -> (y : a) -> (eq : Id a x y) -> Id b (f x) (f y) {
  forall (a : Type) (b : Type) (f : (_ : a) -> b) (x : a)
  cong a b f x [x] [Refl a x] ~> Refl b (f x)
}

one : (x : B) -> List {
  forall (x : B)
  one x ~> Cons x Nil
}

app : (_ : List) -> (_ : List) -> List {
  forall (ys : List)
  app Nil ys ~> ys
  
  forall (x : B) (xs : List) (ys : List)
  app (Cons x xs) ys ~> Cons x (app xs ys)
}

appRightNeutral : (ys : List) -> Id List ys (app ys Nil) {
  appRightNeutral Nil ~> Refl List Nil
  
  forall (x : B) (xs : List)
  appRightNeutral (Cons x xs) ~> cong List List (Cons x) xs (app xs Nil) (appRightNeutral xs)
}

appAssoc : (xs : List) -> (ys : List) -> (zs : List) -> Id List (app (app xs ys) zs) (app xs (app ys zs)) {
  forall (ys : List) (zs : List)
  appAssoc Nil ys zs ~> Refl List (app ys zs)
  
  forall (x : B) (xs : List) (ys : List) (zs : List)
  appAssoc (Cons x xs) ys zs ~> cong List List (Cons x) (app (app xs ys) zs) (app xs (app ys zs)) (appAssoc xs ys zs)
}

mutual {
  constructor/1 Rev : (_ : List) -> Type.
  
  constructor/0 RNil : Rev Nil.
  
  constructor/3 RSnoc : (xs :I List) -> (x : B) -> (rxs : Rev xs) -> Rev (app xs (one x)).
}

rev' : (xs : List) -> (rxs : Rev xs) -> (ys : List) -> Rev (app xs ys) {
  forall (xs : List) (rxs : Rev xs)
  rev' xs rxs Nil ~> subst List Rev xs (app xs Nil) (appRightNeutral xs) rxs
  
  forall (xs : List) (rxs : Rev xs) (y : B) (ys : List)
  rev' xs rxs (Cons y ys) ~> subst List Rev (app (app xs (one y)) ys) (app xs (Cons y ys)) (appAssoc xs (one y) ys) (rev' (app xs (one y)) (RSnoc xs y rxs) ys)
}

rev : (xs : List) -> Rev xs {
  forall (xs : List)
  rev xs ~> rev' Nil RNil xs
}

reverse' : (xs : List) -> (rxs : Rev xs) -> List {
  reverse' [Nil] RNil ~> Nil
  
  forall (xs : List) (x : B) (rxs : Rev xs)
  reverse' [app xs (one x)] (RSnoc xs x rxs) ~> Cons x (reverse' xs rxs)
}

reverse : (_ : List) -> List {
  forall (xs : List)
  reverse xs ~> reverse' xs (rev xs)
}

mutual {
  constructor/1 V : (_ : List) -> Type.
  
  constructor/0 VNil : V Nil.
  
  constructor/1 VOne : (x : B) -> V (Cons x Nil).
  
  constructor/4 VTwo : (x : B) -> (xs :I List) -> (u : V xs) -> (y : B) -> V (Cons x (app xs (one y))).
}

length : (_ : List) -> N {
  length Nil ~> Z
  
  forall (x : B) (xs : List)
  length (Cons x xs) ~> S (length xs)
}

index : (_ : N) -> (_ : List) -> (_ : List) -> List {
  forall (xs : List) (ys : List)
  index Z xs ys ~> Nil
  
  forall (x : B) (xs : List) (y : B) (ys : List)
  index (S Z) (Cons x xs) (Cons y ys) ~> Cons x Nil
  
  forall (n : N) (x : B) (xs : List) (y : B) (ys : List)
  index (S (S n)) (Cons x xs) (Cons y ys) ~> Cons x (app (index n xs ys) (one y))
  
  forall (n : N)
  index (S n) Nil Nil ~> Nil
}

build : (n : N) -> (xs : List) -> (ys : List) -> V (index n xs ys) {
  forall (xs : List) (ys : List)
  build Z xs ys ~> VNil
  
  forall (x : B) (xs : List) (y : B) (ys : List)
  build (S Z) (Cons x xs) (Cons y ys) ~> VOne x
  
  forall (n : N) (x : B) (xs : List) (y : B) (ys : List)
  build (S (S n)) (Cons x xs) (Cons y ys) ~> VTwo x (index n xs ys) (build n xs ys) y
  
  forall (n : N)
  build (S n) Nil Nil ~> VNil
}

postulate eq : (xs : List) -> Id List (index (length xs) xs (reverse xs)) xs.

toV : (xs : List) -> V xs {
  forall (xs : List)
  toV xs ~> subst List V (index (length xs) xs (reverse xs)) xs (eq xs) (build (length xs) xs (reverse xs))
}

mutual {
  constructor/1 IsPalindrome : (_ : List) -> Type.
  
  constructor/0 PNil : IsPalindrome Nil.
  
  constructor/1 POne : (b : B) -> IsPalindrome (Cons b Nil).
  
  constructor/3 PTwo : (b : B) -> (xs :I List) -> (pf : IsPalindrome xs) -> IsPalindrome (Cons b (app xs (one b))).
}

decEq : (x : B) -> (y : B) -> Maybe (Id B x y) {
  decEq T T ~> Just (Id B T T) (Refl B T)
  
  decEq F F ~> Just (Id B F F) (Refl B F)
  
  decEq T F ~> Nothing (Id B T F)
  
  decEq F T ~> Nothing (Id B F T)
}

isPalinV' : (x : B) -> (y : B) -> (xs : List) -> (v : V xs) -> (pfB : Maybe (Id B x y)) -> (pfV : Maybe (IsPalindrome xs)) -> Maybe (IsPalindrome (Cons x (app xs (one y)))) {
  forall (x : B) (xs : List) (v : V xs) (pfV : IsPalindrome xs)
  isPalinV' x [x] xs v (Just [Id B x x] [Refl B x]) (Just [IsPalindrome xs] pfV) ~> Just (IsPalindrome (Cons x (app xs (one x)))) (PTwo x xs pfV)
  
  forall (x : B) (y : B) (xs : List) (v : V xs) (pfB : Maybe (Id B x y)) (pfV : Maybe (IsPalindrome xs))
  isPalinV' x y xs v pfB pfV ~> Nothing (IsPalindrome (Cons x (app xs (one y))))
}

isPalinV : (xs : List) -> (v : V xs) -> Maybe (IsPalindrome xs) {
  isPalinV [Nil] VNil ~> Just (IsPalindrome Nil) PNil
  
  forall (x : B)
  isPalinV [Cons x Nil] (VOne x) ~> Just (IsPalindrome (Cons x Nil)) (POne x)
  
  forall (x : B) (xs : List) (y : B) (v : V xs)
  isPalinV [Cons x (app xs (one y))] (VTwo x xs v y) ~> isPalinV' x y xs v (decEq x y) (isPalinV xs v)
}

isPalindrome : (xs : List) -> Maybe (IsPalindrome xs) {
  forall (xs : List)
  isPalindrome xs ~> isPalinV xs (toV xs)
}

genList : (_ : B) -> (_ : N) -> List {
  forall (b : B)
  genList b Z ~> Nil
  
  forall (b : B) (n : N)
  genList b (S n) ~> Cons b (genList (not b) n)
}

isJust : (a : Type) -> (x : Maybe a) -> B {
  forall (a : Type) (x : a)
  isJust a (Just [a] x) ~> T
  
  forall (a : Type)
  isJust a (Nothing [a]) ~> F
}

testList : List {
  testList  ~> Cons T (Cons F (Cons F (Cons T (Cons F (Cons F (Cons T Nil))))))
}

main : Maybe (IsPalindrome testList) {
  main  ~> isPalindrome testList
}
#############
# Evarified #
#############

mutual {
  constructor/0 N :9 Type.
  
  constructor/0 Z :57 N.
  
  constructor/1 S :40 (_ :L N) -> N.
}

mutual {
  constructor/0 B :0 Type.
  
  constructor/0 T :41 B.
  
  constructor/0 F :2 B.
}

mutual {
  constructor/0 List :7 Type.
  
  constructor/2 Cons :1 (_ :L B) -> (_ :L List) -> List.
  
  constructor/0 Nil :10 List.
}

mutual {
  constructor/1 Maybe :8 (_ :L Type) -> Type.
  
  constructor/1 Nothing :11 (a :I Type) -> Maybe a.
  
  constructor/2 Just :5 (a :I Type) -> (x :L a) -> Maybe a.
}

not :521 (_ :522 B) -> B {
  not T ~> F
  
  not F ~> T
}

mutual {
  constructor/3 Id :3 (a :L Type) -> (x :L a) -> (y :L a) -> Type.
  
  constructor/2 Refl :35 (a :I Type) -> (x :I a) -> Id a x x.
}

id :300 (a :301 Type) -> (_ :302 a) -> a {
  id  ~> \a :303 Type.
      \x :304 a.
        x
}

subst :629 (a :630 Type) -> (P :631 (_ :632 a) -> Type) -> (x :633 a) -> (y :634 a) -> (eq :635 Id a x y) -> (w :639 P x) -> P y {
  forall (a :644 Type) (P :643 (x :E a) -> Type) (x :642 a)
  subst a P x [x] ({Refl} [a] [x]) ~> \w :652 P x.
      w
}

cong :206 (a :207 Type) -> (b :208 Type) -> (f :209 (x :L a) -> b) -> (x :210 a) -> (y :211 a) -> (eq :212 Id a x y) -> Id b (f x) (f y) {
  forall (a :225 Type) (b :224 Type) (f :222 (_ :223 a) -> b) (x :221 a)
  cong a b f x [x] [Refl a x] ~> Refl b (f x)
}

one :525 (x :526 B) -> List {
  forall (x :527 B)
  one x ~> Cons x Nil
}

app :58 (_ :59 List) -> (_ :60 List) -> List {
  forall (ys :61 List)
  app Nil ys ~> ys
  
  forall (x :66 B) (xs :65 List) (ys :64 List)
  app (Cons x xs) ys ~> Cons x (app xs ys)
}

appRightNeutral :126 (ys :127 List) -> Id List ys (app ys Nil) {
  appRightNeutral Nil ~> Refl List Nil
  
  forall (x :137 B) (xs :136 List)
  appRightNeutral (Cons x xs) ~> cong List List (Cons x) xs (app xs Nil) (appRightNeutral xs)
}

appAssoc :75 (xs :76 List) -> (ys :77 List) -> (zs :78 List) -> Id List (app (app xs ys) zs) (app xs (app ys zs)) {
  forall (ys :91 List) (zs :90 List)
  appAssoc Nil ys zs ~> Refl List (app ys zs)
  
  forall (x :102 B) (xs :101 List) (ys :100 List) (zs :99 List)
  appAssoc (Cons x xs) ys zs ~> cong List List (Cons x) (app (app xs ys) zs) (app xs (app ys zs)) (appAssoc xs ys zs)
}

mutual {
  constructor/1 Rev :39 (_ :L List) -> Type.
  
  constructor/0 RNil :27 Rev Nil.
  
  constructor/3 RSnoc :29 (xs :I List) -> (x :L B) -> (rxs :L Rev xs) -> Rev (app xs (one x)).
}

rev' :539 (xs :540 List) -> (rxs :541 Rev xs) -> (ys :543 List) -> Rev (app xs ys) {
  forall (xs :549 List) (rxs :547 Rev xs)
  rev' xs rxs Nil ~> subst List Rev xs (app xs Nil) (appRightNeutral xs) rxs
  
  forall (xs :566 List) (rxs :564 Rev xs) (y :563 B) (ys :562 List)
  rev' xs rxs (Cons y ys) ~> subst List Rev (app (app xs (one y)) ys) (app xs (Cons y ys)) (appAssoc xs (one y) ys) (rev' (app xs (one y)) (RSnoc xs y rxs) ys)
}

rev :531 (xs :532 List) -> Rev xs {
  forall (xs :534 List)
  rev xs ~> rev' Nil RNil xs
}

reverse' :607 (xs :608 List) -> (rxs :609 Rev xs) -> List {
  reverse' [Nil] RNil ~> Nil
  
  forall (xs :616 List) (x :615 B) (rxs :613 Rev xs)
  reverse' [app xs (one x)] (RSnoc xs x rxs) ~> Cons x (reverse' xs rxs)
}

reverse :600 (_ :601 List) -> List {
  forall (xs :602 List)
  reverse xs ~> reverse' xs (rev xs)
}

mutual {
  constructor/1 V :42 (_ :L List) -> Type.
  
  constructor/0 VNil :43 V Nil.
  
  constructor/1 VOne :45 (x :L B) -> V (Cons x Nil).
  
  constructor/4 VTwo :49 (x :L B) -> (xs :I List) -> (u :L V xs) -> (y :L B) -> V (Cons x (app xs (one y))).
}

length :507 (_ :508 List) -> N {
  length Nil ~> Z
  
  forall (x :511 B) (xs :510 List)
  length (Cons x xs) ~> S (length xs)
}

index :305 (_ :306 N) -> (_ :307 List) -> (_ :308 List) -> List {
  forall (xs :310 List) (ys :309 List)
  index Z xs ys ~> Nil
  
  forall (x :317 B) (xs :316 List) (y :315 B) (ys :314 List)
  index (S Z) (Cons x xs) (Cons y ys) ~> Cons x Nil
  
  forall (n :332 N) (x :331 B) (xs :330 List) (y :329 B) (ys :328 List)
  index (S (S n)) (Cons x xs) (Cons y ys) ~> Cons x (app (index n xs ys) (one y))
  
  forall (n :350 N)
  index (S n) Nil Nil ~> Nil
}

build :151 (n :152 N) -> (xs :153 List) -> (ys :154 List) -> V (index n xs ys) {
  forall (xs :160 List) (ys :159 List)
  build Z xs ys ~> VNil
  
  forall (x :167 B) (xs :166 List) (y :165 B) (ys :164 List)
  build (S Z) (Cons x xs) (Cons y ys) ~> VOne x
  
  forall (n :181 N) (x :180 B) (xs :179 List) (y :178 B) (ys :177 List)
  build (S (S n)) (Cons x xs) (Cons y ys) ~> VTwo x (index n xs ys) (build n xs ys) y
  
  forall (n :201 N)
  build (S n) Nil Nil ~> VNil
}

postulate eq :274 (xs :275 List) -> Id List (index (length xs) xs (reverse xs)) xs.

toV :669 (xs :670 List) -> V xs {
  forall (xs :672 List)
  toV xs ~> subst List V (index (length xs) xs (reverse xs)) xs (eq xs) (build (length xs) xs (reverse xs))
}

mutual {
  constructor/1 IsPalindrome :4 (_ :L List) -> Type.
  
  constructor/0 PNil :13 IsPalindrome Nil.
  
  constructor/1 POne :15 (b :L B) -> IsPalindrome (Cons b Nil).
  
  constructor/3 PTwo :19 (b :L B) -> (xs :I List) -> (pf :L IsPalindrome xs) -> IsPalindrome (Cons b (app xs (one b))).
}

decEq :237 (x :238 B) -> (y :239 B) -> Maybe (Id B x y) {
  decEq T T ~> Just (Id B T T) (Refl B T)
  
  decEq F F ~> Just (Id B F F) (Refl B F)
  
  decEq T F ~> Nothing (Id B T F)
  
  decEq F T ~> Nothing (Id B F T)
}

isPalinV' :418 (x :419 B) -> (y :420 B) -> (xs :421 List) -> (v :422 V xs) -> (pfB :424 Maybe (Id B x y)) -> (pfV :429 Maybe (IsPalindrome xs)) -> Maybe (IsPalindrome (Cons x (app xs (one y)))) {
  forall (x :444 B) (xs :443 List) (v :441 V xs) (pfV :439 IsPalindrome xs)
  isPalinV' x [x] xs v (Just [Id B x x] [Refl B x]) (Just [IsPalindrome xs] pfV) ~> Just (IsPalindrome (Cons x (app xs (one x)))) (PTwo x xs pfV)
  
  forall (x :484 B) (y :483 B) (xs :482 List) (v :480 V xs) (pfB :475 Maybe (Id B x y)) (pfV :472 Maybe (IsPalindrome xs))
  isPalinV' x y xs v pfB pfV ~> Nothing (IsPalindrome (Cons x (app xs (one y))))
}

isPalinV :369 (xs :370 List) -> (v :371 V xs) -> Maybe (IsPalindrome xs) {
  isPalinV [Nil] VNil ~> Just (IsPalindrome Nil) PNil
  
  forall (x :380 B)
  isPalinV [Cons x Nil] (VOne x) ~> Just (IsPalindrome (Cons x Nil)) (POne x)
  
  forall (x :396 B) (xs :395 List) (y :394 B) (v :392 V xs)
  isPalinV [Cons x (app xs (one y))] (VTwo x xs v y) ~> isPalinV' x y xs v (decEq x y) (isPalinV xs v)
}

isPalindrome :498 (xs :499 List) -> Maybe (IsPalindrome xs) {
  forall (xs :502 List)
  isPalindrome xs ~> isPalinV xs (toV xs)
}

genList :284 (_ :285 B) -> (_ :286 N) -> List {
  forall (b :287 B)
  genList b Z ~> Nil
  
  forall (b :291 B) (n :290 N)
  genList b (S n) ~> Cons b (genList (not b) n)
}

isJust :355 (a :356 Type) -> (x :357 Maybe a) -> B {
  forall (a :360 Type) (x :359 a)
  isJust a (Just [a] x) ~> T
  
  forall (a :365 Type)
  isJust a (Nothing [a]) ~> F
}

testList :654 List {
  testList  ~> Cons T (Cons F (Cons F (Cons T (Cons F (Cons F (Cons T Nil))))))
}

main :517 Maybe (IsPalindrome testList) {
  main  ~> isPalindrome testList
}
inferring  mutual {
    constructor/0 N :9 Type.
    
    constructor/0 Z :57 N.
    
    constructor/1 S :40 (_ :L N) -> N.
  }

  
  
  variance of evars:
    covariant: []
    contravariant: []
  mutual {
    constructor/0 N :I Type.
    
    constructor/0 Z :I N.
    
    constructor/1 S :I (_ :L N) -> N.
  }

inferring  mutual {
    constructor/0 B :0 Type.
    
    constructor/0 T :41 B.
    
    constructor/0 F :2 B.
  }

  
  
  variance of evars:
    covariant: []
    contravariant: []
  mutual {
    constructor/0 B :I Type.
    
    constructor/0 T :I B.
    
    constructor/0 F :I B.
  }

inferring  mutual {
    constructor/0 List :7 Type.
    
    constructor/2 Cons :1 (_ :L B) -> (_ :L List) -> List.
    
    constructor/0 Nil :10 List.
  }

  
  
  variance of evars:
    covariant: []
    contravariant: []
  mutual {
    constructor/0 List :I Type.
    
    constructor/2 Cons :I (_ :L B) -> (_ :L List) -> List.
    
    constructor/0 Nil :I List.
  }

inferring  mutual {
    constructor/1 Maybe :8 (_ :L Type) -> Type.
    
    constructor/1 Nothing :11 (a :I Type) -> Maybe a.
    
    constructor/2 Just :5 (a :I Type) -> (x :L a) -> Maybe a.
  }

  inferred constraints: 
    L ~ 12
    L ~ 6
  
  
  variance of evars:
    covariant: []
    contravariant: []
  mutual {
    constructor/1 Maybe :I (_ :L Type) -> Type.
    
    constructor/1 Nothing :I (a :I Type) -> Maybe a.
    
    constructor/2 Just :I (a :I Type) -> (x :L a) -> Maybe a.
  }

inferring  not :521 (_ :522 B) -> B {
    not T ~> F
    
    not F ~> T
  }

  inferred constraints: 
    522 ~ 523
    product [522] ≥ sum
      product [L]
    522 ~ 524
    product [522] ≥ sum
      product [L]
  
  
  variance of evars:
    covariant: []
    contravariant: [522]
  not :I (_ :L B) -> B {
    not T ~> F
    
    not F ~> T
  }

inferring  mutual {
    constructor/3 Id :3 (a :L Type) -> (x :L a) -> (y :L a) -> Type.
    
    constructor/2 Refl :35 (a :I Type) -> (x :I a) -> Id a x x.
  }

  inferred constraints: 
    L ~ 38
    L ~ 37
    L ~ 36
  
  
  variance of evars:
    covariant: []
    contravariant: []
  mutual {
    constructor/3 Id :I (a :L Type) -> (x :L a) -> (y :L a) -> Type.
    
    constructor/2 Refl :I (a :I Type) -> (x :I a) -> Id a x x.
  }

inferring  id :300 (a :301 Type) -> (_ :302 a) -> a {
    id  ~> \a :303 Type.
        \x :304 a.
          x
  }

  inferred constraints: 
    303 ≥ sum
    304 ≥ sum
      product []
    303 ~ 301
    304 ~ 302
  
  
  variance of evars:
    covariant: []
    contravariant: [301, 302]
  id :I (a :I Type) -> (_ :R a) -> a {
    id  ~> \a :I Type.
        \x :R a.
          x
  }

inferring  subst :629 (a :630 Type) -> (P :631 (_ :632 a) -> Type) -> (x :633 a) -> (y :634 a) -> (eq :635 Id a x y) -> (w :639 P x) -> P y {
    forall (a :644 Type) (P :643 (x :E a) -> Type) (x :642 a)
    subst a P x [x] ({Refl} [a] [x]) ~> \w :652 P x.
        w
  }

  inferred constraints: 
    L ~ 638
    L ~ 637
    L ~ 636
    632 ~ 640
    632 ~ 641
    644 ~ product [630]
    643 ~ product [631]
    642 ~ product [633]
    630 ~ 645
    631 ~ 646
    632 ~ E
    633 ~ 647
    634 ~ 648
    635 ~ 649
    product [635] ≥ sum
      product [I]
    I ~ 650
    I ~ 651
    636 ~ L
    637 ~ L
    638 ~ L
    644 ≥ sum
    643 ≥ sum
    642 ≥ sum
    E ~ 653
    652 ≥ sum
      product []
    652 ~ 639
    653 ~ 640
    653 ~ 641
  
  
  variance of evars:
    covariant: [632]
    contravariant: [630, 631, 633, 634, 635, 639]
  subst :I (a :I Type) -> (P :I (_ :E a) -> Type) -> (x :I a) -> (y :I a) -> (eq :I Id a x y) -> (w :L P x) -> P y {
    forall (a :I Type) (P :I (x :E a) -> Type) (x :I a)
    subst a P x [x] ({Refl} [a] [x]) ~> \w :L P x.
        w
  }

inferring  cong :206 (a :207 Type) -> (b :208 Type) -> (f :209 (x :L a) -> b) -> (x :210 a) -> (y :211 a) -> (eq :212 Id a x y) -> Id b (f x) (f y) {
    forall (a :225 Type) (b :224 Type) (f :222 (_ :223 a) -> b) (x :221 a)
    cong a b f x [x] [Refl a x] ~> Refl b (f x)
  }

  inferred constraints: 
    L ~ 215
    L ~ 214
    L ~ 213
    L ~ 218
    L ~ 217
    L ~ 219
    L ~ 216
    L ~ 220
    225 ~ product [207]
    224 ~ product [208]
    222 ~ product [209]
    221 ~ product [210]
    207 ~ 226
    208 ~ 227
    209 ~ 228
    L ~ 223
    210 ~ 229
    211 ~ 230
    212 ~ 231
    I ~ 233
    I ~ 232
    213 ~ L
    214 ~ L
    215 ~ L
    225 ≥ sum
    224 ≥ sum
      product [I]
    222 ≥ sum
      product [I]
    221 ≥ sum
      product [223, I]
    I ~ 235
    I ~ 234
    223 ~ 236
    L ~ 216
    L ~ 217
    L ~ 218
  
  deferred equalities: 
    217 -> f x ~ f x
    216 -> f x ~ f x
  
  variance of evars:
    covariant: []
    contravariant: [207, 208, 209, 210, 211, 212]
  -> iteration 1
    f x ~ f x
    f x ~ f x

  cong :I (a :I Type) -> (b :I Type) -> (f :I (x :L a) -> b) -> (x :R a) -> (y :I a) -> (eq :I Id a x y) -> Id b (f x) (f y) {
    forall (a :I Type) (b :I Type) (f :I (_ :L a) -> b) (x :R a)
    cong a b f x [x] [Refl a x] ~> Refl b (f x)
  }

inferring  one :525 (x :526 B) -> List {
    forall (x :527 B)
    one x ~> Cons x Nil
  }

  inferred constraints: 
    527 ~ product [526]
    526 ~ 528
    527 ≥ sum
      product [L]
    L ~ 530
    L ~ 529
  
  
  variance of evars:
    covariant: []
    contravariant: [526]
  one :I (x :L B) -> List {
    forall (x :L B)
    one x ~> Cons x Nil
  }

inferring  app :58 (_ :59 List) -> (_ :60 List) -> List {
    forall (ys :61 List)
    app Nil ys ~> ys
    
    forall (x :66 B) (xs :65 List) (ys :64 List)
    app (Cons x xs) ys ~> Cons x (app xs ys)
  }

  inferred constraints: 
    61 ~ product [60]
    59 ~ 62
    product [59] ≥ sum
      product [L]
    60 ~ 63
    61 ≥ sum
      product []
    66 ~ product [L, 59]
    65 ~ product [L, 59]
    64 ~ product [60]
    59 ~ 67
    product [59] ≥ sum
      product [L]
    L ~ 68
    L ~ 69
    60 ~ 70
    66 ≥ sum
      product [L]
    65 ≥ sum
      product [59, L]
    64 ≥ sum
      product [60, L]
    L ~ 72
    L ~ 71
    59 ~ 74
    60 ~ 73
  
  
  variance of evars:
    covariant: []
    contravariant: [59, 60]
  app :I (_ :L List) -> (_ :L List) -> List {
    forall (ys :L List)
    app Nil ys ~> ys
    
    forall (x :L B) (xs :L List) (ys :L List)
    app (Cons x xs) ys ~> Cons x (app xs ys)
  }

inferring  appRightNeutral :126 (ys :127 List) -> Id List ys (app ys Nil) {
    appRightNeutral Nil ~> Refl List Nil
    
    forall (x :137 B) (xs :136 List)
    appRightNeutral (Cons x xs) ~> cong List List (Cons x) xs (app xs Nil) (appRightNeutral xs)
  }

  inferred constraints: 
    L ~ 130
    L ~ 129
    L ~ 128
    L ~ 132
    L ~ 131
    127 ~ 133
    product [127] ≥ sum
      product [L]
    I ~ 135
    I ~ 134
    L ~ 128
    L ~ 129
    L ~ 130
    137 ~ product [L, 127]
    136 ~ product [L, 127]
    127 ~ 138
    product [127] ≥ sum
      product [L]
    L ~ 139
    L ~ 140
    137 ≥ sum
      product [L, I]
    136 ≥ sum
      product [R]
      product [L, I]
      product [127, I]
    I ~ 146
    I ~ 145
    I ~ 144
    L ~ 147
    R ~ 143
    I ~ 142
    L ~ 149
    L ~ 148
    I ~ 141
    127 ~ 150
    L ~ 128
    L ~ 129
    L ~ 130
    L ~ 128
    L ~ 129
    L ~ 130
  
  deferred equalities: 
    128 -> app Nil Nil ~ Nil
    128 -> app xs Nil ~ app xs Nil
    129 -> Cons x xs ~ Cons x xs
    128 -> app (Cons x xs) Nil ~ Cons x (app xs Nil)
  
  variance of evars:
    covariant: []
    contravariant: [127]
  -> iteration 1
    app Nil Nil ~ Nil
    app xs Nil ~ app xs Nil
    Cons x xs ~ Cons x xs
    app (Cons x xs) Nil ~ Cons x (app xs Nil)

  appRightNeutral :I (ys :R List) -> Id List ys (app ys Nil) {
    appRightNeutral Nil ~> Refl List Nil
    
    forall (x :R B) (xs :R List)
    appRightNeutral (Cons x xs) ~> cong List List (Cons x) xs (app xs Nil) (appRightNeutral xs)
  }

inferring  appAssoc :75 (xs :76 List) -> (ys :77 List) -> (zs :78 List) -> Id List (app (app xs ys) zs) (app xs (app ys zs)) {
    forall (ys :91 List) (zs :90 List)
    appAssoc Nil ys zs ~> Refl List (app ys zs)
    
    forall (x :102 B) (xs :101 List) (ys :100 List) (zs :99 List)
    appAssoc (Cons x xs) ys zs ~> cong List List (Cons x) (app (app xs ys) zs) (app xs (app ys zs)) (appAssoc xs ys zs)
  }

  inferred constraints: 
    L ~ 81
    L ~ 80
    L ~ 83
    L ~ 85
    L ~ 84
    L ~ 82
    L ~ 79
    L ~ 87
    L ~ 86
    L ~ 89
    L ~ 88
    91 ~ product [77]
    90 ~ product [78]
    76 ~ 92
    product [76] ≥ sum
      product [L]
    77 ~ 93
    78 ~ 94
    91 ≥ sum
      product [L, I]
    90 ≥ sum
      product [L, I]
    I ~ 96
    I ~ 95
    L ~ 98
    L ~ 97
    L ~ 79
    L ~ 80
    L ~ 81
    102 ~ product [L, 76]
    101 ~ product [L, 76]
    100 ~ product [77]
    99 ~ product [78]
    76 ~ 103
    product [76] ≥ sum
      product [L]
    L ~ 104
    L ~ 105
    77 ~ 106
    78 ~ 107
    102 ≥ sum
      product [L, I]
    101 ≥ sum
      product [L, L, R]
      product [L, I]
      product [76, I]
    100 ≥ sum
      product [L, L, R]
      product [L, L, I]
      product [77, I]
    99 ≥ sum
      product [L, R]
      product [L, L, I]
      product [78, I]
    I ~ 113
    I ~ 112
    I ~ 111
    L ~ 114
    R ~ 110
    L ~ 116
    L ~ 118
    L ~ 117
    L ~ 115
    I ~ 109
    L ~ 120
    L ~ 119
    L ~ 122
    L ~ 121
    I ~ 108
    76 ~ 125
    77 ~ 124
    78 ~ 123
    L ~ 79
    L ~ 80
    L ~ 81
    L ~ 79
    L ~ 80
    L ~ 81
  
  deferred equalities: 
    80 -> app (app Nil ys) zs ~ app ys zs
    79 -> app Nil (app ys zs) ~ app ys zs
    80 -> app (app xs ys) zs ~ app (app xs ys) zs
    79 -> app xs (app ys zs) ~ app xs (app ys zs)
    80 -> app (app (Cons x xs) ys) zs ~ Cons x (app (app xs ys) zs)
    79 -> app (Cons x xs) (app ys zs) ~ Cons x (app xs (app ys zs))
  
  variance of evars:
    covariant: []
    contravariant: [76, 77, 78]
  -> iteration 1
    app (app Nil ys) zs ~ app ys zs
    app Nil (app ys zs) ~ app ys zs
    app (app xs ys) zs ~ app (app xs ys) zs
    app xs (app ys zs) ~ app xs (app ys zs)
    app (app (Cons x xs) ys) zs ~ Cons x (app (app xs ys) zs)
    app (Cons x xs) (app ys zs) ~ Cons x (app xs (app ys zs))

  -> iteration 2
    app Nil ys ~ ys
    app xs ys ~ app xs ys
    app ys zs ~ app ys zs

  appAssoc :I (xs :R List) -> (ys :R List) -> (zs :R List) -> Id List (app (app xs ys) zs) (app xs (app ys zs)) {
    forall (ys :R List) (zs :R List)
    appAssoc Nil ys zs ~> Refl List (app ys zs)
    
    forall (x :R B) (xs :R List) (ys :R List) (zs :R List)
    appAssoc (Cons x xs) ys zs ~> cong List List (Cons x) (app (app xs ys) zs) (app xs (app ys zs)) (appAssoc xs ys zs)
  }

inferring  mutual {
    constructor/1 Rev :39 (_ :L List) -> Type.
    
    constructor/0 RNil :27 Rev Nil.
    
    constructor/3 RSnoc :29 (xs :I List) -> (x :L B) -> (rxs :L Rev xs) -> Rev (app xs (one x)).
  }

  inferred constraints: 
    L ~ 28
    L ~ 30
    L ~ 31
    L ~ 33
    L ~ 32
    L ~ 34
  
  
  variance of evars:
    covariant: []
    contravariant: []
  mutual {
    constructor/1 Rev :I (_ :L List) -> Type.
    
    constructor/0 RNil :I Rev Nil.
    
    constructor/3 RSnoc :I (xs :I List) -> (x :L B) -> (rxs :L Rev xs) -> Rev (app xs (one x)).
  }

inferring  rev' :539 (xs :540 List) -> (rxs :541 Rev xs) -> (ys :543 List) -> Rev (app xs ys) {
    forall (xs :549 List) (rxs :547 Rev xs)
    rev' xs rxs Nil ~> subst List Rev xs (app xs Nil) (appRightNeutral xs) rxs
    
    forall (xs :566 List) (rxs :564 Rev xs) (y :563 B) (ys :562 List)
    rev' xs rxs (Cons y ys) ~> subst List Rev (app (app xs (one y)) ys) (app xs (Cons y ys)) (appAssoc xs (one y) ys) (rev' (app xs (one y)) (RSnoc xs y rxs) ys)
  }

error: With backtrace:
  "DEF":  rev' :539 (xs :540 List) -> (rxs :541 Rev xs) -> (ys :543 List) -> Rev (app xs ys) {
    forall (xs :549 List) (rxs :547 Rev xs)
    rev' xs rxs Nil ~> subst List Rev xs (app xs Nil) (appRightNeutral xs) rxs
    
    forall (xs :566 List) (rxs :564 Rev xs) (y :563 B) (ys :562 List)
    rev' xs rxs (Cons y ys) ~> subst List Rev (app (app xs (one y)) ys) (app xs (Cons y ys)) (appAssoc xs (one y) ys) (rev' (app xs (one y)) (RSnoc xs y rxs) ys)
  }
  "CLAUSE":  forall (xs :549 List) (rxs :547 Rev xs)
  rev' xs rxs Nil ~> subst List Rev xs (app xs Nil) (appRightNeutral xs) rxs
  "CLAUSE-RHS": subst List Rev xs (app xs Nil) (appRightNeutral xs) rxs
  "APP": subst List Rev xs (app xs Nil) (appRightNeutral xs) rxs
  "APP": subst List Rev xs (app xs Nil) (appRightNeutral xs)
  "APP": subst List Rev xs (app xs Nil)
  "APP": subst List Rev xs
  "APP": subst List Rev
  "fTy": ((P :I (_ :E List) -> Type) -> (x :I List) -> (y :I List) -> (eq :I Id List x y) -> (w :L P x) -> P y)
  "xTy": ((_ :L List) -> Type)
quantity mismatch: L /= E
