
#############
# Desugared #
#############

mutual {
  constructor/0 N : Type.
  
  constructor/0 Z : N.
  
  constructor/1 S : (_ : N) -> N.
}

mutual {
  constructor/0 B : Type.
  
  constructor/0 T : B.
  
  constructor/0 F : B.
}

mutual {
  constructor/0 List : Type.
  
  constructor/2 Cons : (_ : B) -> (_ : List) -> List.
  
  constructor/0 Nil : List.
}

mutual {
  constructor/1 Maybe : (_ : Type) -> Type.
  
  constructor/1 Nothing : (a : _) -> Maybe a.
  
  constructor/2 Just : (a : _) -> (_ : a) -> Maybe a.
}

not : (_ : B) -> B {
  not T ~> F
  
  not F ~> T
}

mutual {
  constructor/3 Id : (a : _) -> (_ : a) -> (_ : a) -> Type.
  
  constructor/2 Refl : (a : _) -> (x :I a) -> Id a x x.
}

id : (a : _) -> (_ : a) -> a {
  id  ~> \a : _.
      \x : _.
        x
}

subst : (a : _) -> (P : (x :L a) -> Type) -> (x : a) -> (y : a) -> (_ : Id a x y) -> (_ : P x) -> P y {
  forall (a : _) (P : (_ : _) -> _) (x : _).
  subst a P x [x] ({Refl} [a] [x]) ~> \w : _.
      w
}

cong : (a : _) -> (b : _) -> (f : (x :L a) -> b) -> (x : a) -> (y : a) -> (_ : Id a x y) -> Id b (f x) (f y) {
  forall (a : _) (b : _) (f : (_ : _) -> _) (x : _).
  cong a b f x [x] [Refl a x] ~> Refl b (f x)
}

one : (x : B) -> List {
  forall (x : _).
  one x ~> Cons x Nil
}

app : (_ : List) -> (_ : List) -> List {
  forall (ys : _).
  app Nil ys ~> ys
  
  forall (x : _) (xs : _) (ys : _).
  app (Cons x xs) ys ~> Cons x (app xs ys)
}

appRightNeutral : (ys : _) -> Id List ys (app ys Nil) {
  appRightNeutral Nil ~> Refl List Nil
  
  forall (x : _) (xs : _).
  appRightNeutral (Cons x xs) ~> cong List List (Cons x) xs (app xs Nil) (appRightNeutral xs)
}

appAssoc : (xs : _) -> (ys : _) -> (zs : _) -> Id List (app (app xs ys) zs) (app xs (app ys zs)) {
  forall (ys : _) (zs : _).
  appAssoc Nil ys zs ~> Refl List (app ys zs)
  
  forall (x : _) (xs : _) (ys : _) (zs : _).
  appAssoc (Cons x xs) ys zs ~> cong List List (Cons x) (app (app xs ys) zs) (app xs (app ys zs)) (appAssoc xs ys zs)
}

mutual {
  constructor/1 Rev : (_ : List) -> Type.
  
  constructor/0 RNil : Rev Nil.
  
  constructor/3 RSnoc : (xs : _) -> (x : B) -> (rxs : Rev xs) -> Rev (app xs (one x)).
}

rev' : (xs : _) -> (rxs : Rev xs) -> (ys : List) -> Rev (app xs ys) {
  forall (xs : _) (rxs : _).
  rev' xs rxs Nil ~> subst List Rev xs (app xs Nil) (appRightNeutral xs) rxs
  
  forall (xs : _) (rxs : _) (y : _) (ys : _).
  rev' xs rxs (Cons y ys) ~> subst List Rev (app (app xs (one y)) ys) (app xs (Cons y ys)) (appAssoc xs (one y) ys) (rev' (app xs (one y)) (RSnoc xs y rxs) ys)
}

rev : (xs : List) -> Rev xs {
  forall (xs : _).
  rev xs ~> rev' Nil RNil xs
}

reverse' : (xs : _) -> (rxs : Rev xs) -> List {
  reverse' [Nil] RNil ~> Nil
  
  forall (xs : _) (x : _) (rxs : _).
  reverse' [app xs (one x)] (RSnoc xs x rxs) ~> Cons x (reverse' xs rxs)
}

reverse : (_ : List) -> List {
  forall (xs : List).
  reverse xs ~> reverse' xs (rev xs)
}

mutual {
  constructor/1 V : (_ : List) -> Type.
  
  constructor/0 VNil : V Nil.
  
  constructor/1 VOne : (x : B) -> V (Cons x Nil).
  
  constructor/4 VTwo : (x : B) -> (xs : _) -> (u : V xs) -> (y : B) -> V (Cons x (app xs (one y))).
}

length : (_ : List) -> N {
  length Nil ~> Z
  
  forall (x : _) (xs : _).
  length (Cons x xs) ~> S (length xs)
}

index : (_ : N) -> (_ : List) -> (_ : List) -> List {
  forall (xs : _) (ys : _).
  index Z xs ys ~> Nil
  
  forall (x : _) (xs : _) (y : _) (ys : _).
  index (S Z) (Cons x xs) (Cons y ys) ~> Cons x Nil
  
  forall (n : _) (x : _) (xs : _) (y : _) (ys : _).
  index (S (S n)) (Cons x xs) (Cons y ys) ~> Cons x (app (index n xs ys) (one y))
  
  forall (n : _).
  index (S n) Nil Nil ~> Nil
}

build : (n : N) -> (xs : List) -> (ys : List) -> V (index n xs ys) {
  forall (xs : _) (ys : _).
  build Z xs ys ~> VNil
  
  forall (x : _) (xs : _) (y : _) (ys : _).
  build (S Z) (Cons x xs) (Cons y ys) ~> VOne x
  
  forall (n : _) (x : _) (xs : _) (y : _) (ys : _).
  build (S (S n)) (Cons x xs) (Cons y ys) ~> VTwo x (index n xs ys) (build n xs ys) y
  
  forall (n : _).
  build (S n) Nil Nil ~> VNil
}

postulate eq : (xs : List) -> Id List (index (length xs) xs (reverse xs)) xs.

toV : (xs : List) -> V xs {
  forall (xs : _).
  toV xs ~> subst List V (index (length xs) xs (reverse xs)) xs (eq xs) (build (length xs) xs (reverse xs))
}

mutual {
  constructor/1 IsPalindrome : (_ : List) -> Type.
  
  constructor/0 PNil : IsPalindrome Nil.
  
  constructor/1 POne : (b : B) -> IsPalindrome (Cons b Nil).
  
  constructor/3 PTwo : (b : B) -> (xs : _) -> (pf : IsPalindrome xs) -> IsPalindrome (Cons b (app xs (one b))).
}

decEq : (x : B) -> (y : B) -> Maybe (Id B x y) {
  decEq T T ~> Just (Id B T T) (Refl B T)
  
  decEq F F ~> Just (Id B F F) (Refl B F)
  
  decEq T F ~> Nothing (Id B T F)
  
  decEq F T ~> Nothing (Id B F T)
}

isPalinV' : (x : B) -> (y : B) -> (xs :I List) -> (v : V xs) -> (pfB : Maybe (Id B x y)) -> (pfV : Maybe (IsPalindrome xs)) -> Maybe (IsPalindrome (Cons x (app xs (one y)))) {
  forall (x : _) (xs : _) (v : _) (pfV : _).
  isPalinV' x [x] xs v (Just [Id B x x] [Refl B x]) (Just [IsPalindrome xs] pfV) ~> Just (IsPalindrome (Cons x (app xs (one x)))) (PTwo x xs pfV)
  
  forall (x : _) (y : _) (xs : _) (v : _) (pfB : _) (pfV : _).
  isPalinV' x y xs v pfB pfV ~> Nothing (IsPalindrome (Cons x (app xs (one y))))
}

isPalinV : (xs : List) -> (v : V xs) -> Maybe (IsPalindrome xs) {
  isPalinV [Nil] VNil ~> Just (IsPalindrome Nil) PNil
  
  forall (x : _).
  isPalinV [Cons x Nil] (VOne x) ~> Just (IsPalindrome (Cons x Nil)) (POne x)
  
  forall (x : _) (xs : _) (y : _) (v : _).
  isPalinV [Cons x (app xs (one y))] (VTwo x xs v y) ~> isPalinV' x y xs v (decEq x y) (isPalinV xs v)
}

isPalindrome : (xs : List) -> Maybe (IsPalindrome xs) {
  forall (xs : _).
  isPalindrome xs ~> isPalinV xs (toV xs)
}

genList : (_ : B) -> (_ : N) -> List {
  forall (b : _).
  genList b Z ~> Nil
  
  forall (b : _) (n : _).
  genList b (S n) ~> Cons b (genList (not b) n)
}

isJust : (a : _) -> (x : Maybe a) -> B {
  forall (a : _) (x : _).
  isJust a (Just [a] x) ~> T
  
  forall (a : _).
  isJust a (Nothing [a]) ~> F
}

testList : List {
  testList  ~> Cons T (Cons F (Cons F (Cons T (Cons F (Cons F (Cons T Nil))))))
}

main : Maybe (IsPalindrome testList) {
  main  ~> isPalindrome testList
}

###############
# Elaboration #
###############

mutual {
  constructor/0 N : Type.
  
  constructor/0 Z : N.
  
  constructor/1 S : (_ :L N) -> N.
}

mutual {
  constructor/0 B : Type.
  
  constructor/0 T : B.
  
  constructor/0 F : B.
}

mutual {
  constructor/0 List : Type.
  
  constructor/2 Cons : (_ :L B) -> (_ :L List) -> List.
  
  constructor/0 Nil : List.
}

mutual {
  constructor/1 Maybe : (_ :L Type) -> Type.
  
  constructor/1 Nothing : (a :I _0) -> Maybe a.
  
  constructor/2 Just : (a :I _1) -> (_ :L a) -> Maybe a.
}

not : (_ : B) -> B {
  not T ~> F
  
  not F ~> T
}

mutual {
  constructor/3 Id : (a :I _2) -> (_ :L a) -> (_ :L a) -> Type.
  
  constructor/2 Refl : (a :I _3) -> (x :I a) -> Id a x x.
}

id : (a : _4) -> (_ : a) -> a {
  id  ~> \a : _5.
      \x : _6.
        x
}

subst : (a : _7) -> (P : (x :L a) -> Type) -> (x : a) -> (y : a) -> (_ : Id a x y) -> (_ : P x) -> P y {
  forall (a : _11) (P : (_ : _9) -> _10) (x : _8).
  subst a P x [x] ({Refl} [a] [x]) ~> \w : _12.
      w
}

cong : (a : _13) -> (b : _14) -> (f : (x :L a) -> b) -> (x : a) -> (y : a) -> (_ : Id a x y) -> Id b (f x) (f y) {
  forall (a : _19) (b : _18) (f : (_ : _16) -> _17) (x : _15).
  cong a b f x [x] [Refl a x] ~> Refl b (f x)
}

one : (x : B) -> List {
  forall (x : _20).
  one x ~> Cons x Nil
}

app : (_ : List) -> (_ : List) -> List {
  forall (ys : _21).
  app Nil ys ~> ys
  
  forall (x : _24) (xs : _23) (ys : _22).
  app (Cons x xs) ys ~> Cons x (app xs ys)
}

appRightNeutral : (ys : _25) -> Id List ys (app ys Nil) {
  appRightNeutral Nil ~> Refl List Nil
  
  forall (x : _27) (xs : _26).
  appRightNeutral (Cons x xs) ~> cong List List (Cons x) xs (app xs Nil) (appRightNeutral xs)
}

appAssoc : (xs : _28) -> (ys : _29) -> (zs : _30) -> Id List (app (app xs ys) zs) (app xs (app ys zs)) {
  forall (ys : _32) (zs : _31).
  appAssoc Nil ys zs ~> Refl List (app ys zs)
  
  forall (x : _36) (xs : _35) (ys : _34) (zs : _33).
  appAssoc (Cons x xs) ys zs ~> cong List List (Cons x) (app (app xs ys) zs) (app xs (app ys zs)) (appAssoc xs ys zs)
}

mutual {
  constructor/1 Rev : (_ :L List) -> Type.
  
  constructor/0 RNil : Rev Nil.
  
  constructor/3 RSnoc : (xs :I _37) -> (x :L B) -> (rxs :L Rev xs) -> Rev (app xs (one x)).
}

rev' : (xs : _38) -> (rxs : Rev xs) -> (ys : List) -> Rev (app xs ys) {
  forall (xs : _40) (rxs : _39).
  rev' xs rxs Nil ~> subst List Rev xs (app xs Nil) (appRightNeutral xs) rxs
  
  forall (xs : _44) (rxs : _43) (y : _42) (ys : _41).
  rev' xs rxs (Cons y ys) ~> subst List Rev (app (app xs (one y)) ys) (app xs (Cons y ys)) (appAssoc xs (one y) ys) (rev' (app xs (one y)) (RSnoc xs y rxs) ys)
}

rev : (xs : List) -> Rev xs {
  forall (xs : _45).
  rev xs ~> rev' Nil RNil xs
}

reverse' : (xs : _46) -> (rxs : Rev xs) -> List {
  reverse' [Nil] RNil ~> Nil
  
  forall (xs : _49) (x : _48) (rxs : _47).
  reverse' [app xs (one x)] (RSnoc xs x rxs) ~> Cons x (reverse' xs rxs)
}

reverse : (_ : List) -> List {
  forall (xs : List).
  reverse xs ~> reverse' xs (rev xs)
}

mutual {
  constructor/1 V : (_ :L List) -> Type.
  
  constructor/0 VNil : V Nil.
  
  constructor/1 VOne : (x :L B) -> V (Cons x Nil).
  
  constructor/4 VTwo : (x :L B) -> (xs :I _50) -> (u :L V xs) -> (y :L B) -> V (Cons x (app xs (one y))).
}

length : (_ : List) -> N {
  length Nil ~> Z
  
  forall (x : _52) (xs : _51).
  length (Cons x xs) ~> S (length xs)
}

index : (_ : N) -> (_ : List) -> (_ : List) -> List {
  forall (xs : _54) (ys : _53).
  index Z xs ys ~> Nil
  
  forall (x : _58) (xs : _57) (y : _56) (ys : _55).
  index (S Z) (Cons x xs) (Cons y ys) ~> Cons x Nil
  
  forall (n : _63) (x : _62) (xs : _61) (y : _60) (ys : _59).
  index (S (S n)) (Cons x xs) (Cons y ys) ~> Cons x (app (index n xs ys) (one y))
  
  forall (n : _64).
  index (S n) Nil Nil ~> Nil
}

build : (n : N) -> (xs : List) -> (ys : List) -> V (index n xs ys) {
  forall (xs : _66) (ys : _65).
  build Z xs ys ~> VNil
  
  forall (x : _70) (xs : _69) (y : _68) (ys : _67).
  build (S Z) (Cons x xs) (Cons y ys) ~> VOne x
  
  forall (n : _75) (x : _74) (xs : _73) (y : _72) (ys : _71).
  build (S (S n)) (Cons x xs) (Cons y ys) ~> VTwo x (index n xs ys) (build n xs ys) y
  
  forall (n : _76).
  build (S n) Nil Nil ~> VNil
}

postulate eq : (xs : List) -> Id List (index (length xs) xs (reverse xs)) xs.

toV : (xs : List) -> V xs {
  forall (xs : _77).
  toV xs ~> subst List V (index (length xs) xs (reverse xs)) xs (eq xs) (build (length xs) xs (reverse xs))
}

mutual {
  constructor/1 IsPalindrome : (_ :L List) -> Type.
  
  constructor/0 PNil : IsPalindrome Nil.
  
  constructor/1 POne : (b :L B) -> IsPalindrome (Cons b Nil).
  
  constructor/3 PTwo : (b :L B) -> (xs :I _78) -> (pf :L IsPalindrome xs) -> IsPalindrome (Cons b (app xs (one b))).
}

decEq : (x : B) -> (y : B) -> Maybe (Id B x y) {
  decEq T T ~> Just (Id B T T) (Refl B T)
  
  decEq F F ~> Just (Id B F F) (Refl B F)
  
  decEq T F ~> Nothing (Id B T F)
  
  decEq F T ~> Nothing (Id B F T)
}

isPalinV' : (x : B) -> (y : B) -> (xs :I List) -> (v : V xs) -> (pfB : Maybe (Id B x y)) -> (pfV : Maybe (IsPalindrome xs)) -> Maybe (IsPalindrome (Cons x (app xs (one y)))) {
  forall (x : _82) (xs : _81) (v : _80) (pfV : _79).
  isPalinV' x [x] xs v (Just [Id B x x] [Refl B x]) (Just [IsPalindrome xs] pfV) ~> Just (IsPalindrome (Cons x (app xs (one x)))) (PTwo x xs pfV)
  
  forall (x : _88) (y : _87) (xs : _86) (v : _85) (pfB : _84) (pfV : _83).
  isPalinV' x y xs v pfB pfV ~> Nothing (IsPalindrome (Cons x (app xs (one y))))
}

isPalinV : (xs : List) -> (v : V xs) -> Maybe (IsPalindrome xs) {
  isPalinV [Nil] VNil ~> Just (IsPalindrome Nil) PNil
  
  forall (x : _89).
  isPalinV [Cons x Nil] (VOne x) ~> Just (IsPalindrome (Cons x Nil)) (POne x)
  
  forall (x : _93) (xs : _92) (y : _91) (v : _90).
  isPalinV [Cons x (app xs (one y))] (VTwo x xs v y) ~> isPalinV' x y xs v (decEq x y) (isPalinV xs v)
}

isPalindrome : (xs : List) -> Maybe (IsPalindrome xs) {
  forall (xs : _94).
  isPalindrome xs ~> isPalinV xs (toV xs)
}

genList : (_ : B) -> (_ : N) -> List {
  forall (b : _95).
  genList b Z ~> Nil
  
  forall (b : _97) (n : _96).
  genList b (S n) ~> Cons b (genList (not b) n)
}

isJust : (a : _98) -> (x : Maybe a) -> B {
  forall (a : _100) (x : _99).
  isJust a (Just [a] x) ~> T
  
  forall (a : _101).
  isJust a (Nothing [a]) ~> F
}

testList : List {
  testList  ~> Cons T (Cons F (Cons F (Cons T (Cons F (Cons F (Cons T Nil))))))
}

main : Maybe (IsPalindrome testList) {
  main  ~> isPalindrome testList
}

Equalities:
  _ty0 = Type
  _0 = Type
  _ty1 = Type
  _1 = Type
  _1 = Type
  _ty2 = Type
  _2 = Type
  _2 = Type
  _ty3 = Type
  _3 = Type
  _2 = _3
  _ty4 = Type
  _4 = Type
  _4 = Type
  _ty5 = Type
  _ty6 = Type
  _4 = _5
  _6 = a
  _6 = a
  _ty7 = Type
  _7 = Type
  _7 = Type
  _7 = Type
  _2 = _7
  _ty11 = Type
  _ty9 = Type
  _ty10 = Type
  _ty8 = Type
  _7 = _11
  _9 = a
  _10 = Type
  _8 = a
  _8 = a
  _3 = _11
  _8 = a
  _ty12 = Type
  _12 = P x
  _12 = P x
  _ty13 = Type
  _ty14 = Type
  _13 = Type
  _14 = Type
  _13 = Type
  _13 = Type
  _2 = _13
  _2 = _14
  _ty19 = Type
  _ty18 = Type
  _ty16 = Type
  _ty17 = Type
  _ty15 = Type
  _13 = _19
  _14 = _18
  _16 = a
  _17 = b
  _15 = a
  _15 = a
  _3 = _19
  _15 = a
  _3 = _18
  _16 = _15
  _17 = b
  _ty20 = Type
  _20 = B
  _20 = B
  _ty21 = Type
  _21 = List
  _21 = List
  _ty24 = Type
  _ty23 = Type
  _ty22 = Type
  _24 = B
  _23 = List
  _22 = List
  _24 = B
  _23 = List
  _22 = List
  _ty25 = Type
  _2 = Type
  _25 = List
  _25 = List
  _25 = List
  _3 = Type
  _ty27 = Type
  _ty26 = Type
  _27 = B
  _26 = List
  _25 = List
  _13 = Type
  _14 = Type
  _27 = B
  _26 = List
  _26 = List
  _25 = _26
  _ty28 = Type
  _ty29 = Type
  _ty30 = Type
  _2 = Type
  _28 = List
  _29 = List
  _30 = List
  _28 = List
  _29 = List
  _30 = List
  _ty32 = Type
  _ty31 = Type
  _28 = List
  _29 = _32
  _30 = _31
  _3 = Type
  _32 = List
  _31 = List
  _ty36 = Type
  _ty35 = Type
  _ty34 = Type
  _ty33 = Type
  _36 = B
  _35 = List
  _28 = List
  _29 = _34
  _30 = _33
  _13 = Type
  _14 = Type
  _36 = B
  _35 = List
  _34 = List
  _33 = List
  _35 = List
  _34 = List
  _33 = List
  _28 = _35
  _29 = _34
  _30 = _33
  _ty37 = Type
  _37 = List
  _37 = List
  _ty38 = Type
  _38 = List
  _38 = List
  _ty40 = Type
  _ty39 = Type
  _38 = _40
  _39 = Rev xs
  _7 = Type
  _40 = List
  _40 = List
  _25 = _40
  _39 = Rev xs
  _ty44 = Type
  _ty43 = Type
  _ty42 = Type
  _ty41 = Type
  _38 = _44
  _43 = Rev xs
  _42 = B
  _41 = List
  _7 = Type
  _44 = List
  _42 = B
  _41 = List
  _44 = List
  _42 = B
  _41 = List
  _28 = _44
  _42 = B
  _29 = List
  _30 = _41
  _44 = List
  _42 = B
  _38 = List
  _37 = _44
  _42 = B
  _43 = Rev xs
  _41 = List
  _ty45 = Type
  _45 = List
  _38 = List
  _45 = List
  _ty46 = Type
  _46 = List
  _46 = List
  _ty49 = Type
  _ty48 = Type
  _ty47 = Type
  _49 = List
  _48 = B
  _46 = List
  _37 = _49
  _48 = B
  _47 = Rev xs
  _48 = B
  _46 = _49
  _47 = Rev xs
  _46 = List
  _ty50 = Type
  _50 = List
  _50 = List
  _ty52 = Type
  _ty51 = Type
  _52 = B
  _51 = List
  _51 = List
  _ty54 = Type
  _ty53 = Type
  _54 = List
  _53 = List
  _ty58 = Type
  _ty57 = Type
  _ty56 = Type
  _ty55 = Type
  _58 = B
  _57 = List
  _56 = B
  _55 = List
  _58 = B
  _ty63 = Type
  _ty62 = Type
  _ty61 = Type
  _ty60 = Type
  _ty59 = Type
  _63 = N
  _62 = B
  _61 = List
  _60 = B
  _59 = List
  _62 = B
  _63 = N
  _61 = List
  _59 = List
  _60 = B
  _ty64 = Type
  _64 = N
  _ty66 = Type
  _ty65 = Type
  _66 = List
  _65 = List
  _ty70 = Type
  _ty69 = Type
  _ty68 = Type
  _ty67 = Type
  _70 = B
  _69 = List
  _68 = B
  _67 = List
  _70 = B
  _ty75 = Type
  _ty74 = Type
  _ty73 = Type
  _ty72 = Type
  _ty71 = Type
  _75 = N
  _74 = B
  _73 = List
  _72 = B
  _71 = List
  _74 = B
  _75 = N
  _73 = List
  _71 = List
  _50 = List
  _75 = N
  _73 = List
  _71 = List
  _72 = B
  _ty76 = Type
  _76 = N
  _2 = Type
  _ty77 = Type
  _77 = List
  _7 = Type
  _77 = List
  _77 = List
  _77 = List
  _77 = List
  _77 = List
  _77 = List
  _77 = List
  _77 = List
  _ty78 = Type
  _78 = List
  _78 = List
  _2 = Type
  _2 = Type
  _1 = Type
  _3 = Type
  _2 = Type
  _1 = Type
  _3 = Type
  _2 = Type
  _0 = Type
  _2 = Type
  _0 = Type
  _2 = Type
  _ty82 = Type
  _ty81 = Type
  _ty80 = Type
  _ty79 = Type
  _82 = B
  _82 = B
  _81 = List
  _80 = V xs
  _2 = Type
  _82 = B
  _82 = B
  _1 = Type
  _3 = Type
  _82 = B
  _81 = List
  _1 = Type
  _79 = IsPalindrome xs
  _82 = B
  _81 = List
  _82 = B
  _1 = Type
  _82 = B
  _78 = _81
  _79 = IsPalindrome xs
  _ty88 = Type
  _ty87 = Type
  _ty86 = Type
  _ty85 = Type
  _ty84 = Type
  _ty83 = Type
  _88 = B
  _87 = B
  _86 = List
  _85 = V xs
  _84 = Maybe (Id B x y)
  _83 = Maybe (IsPalindrome xs)
  _88 = B
  _86 = List
  _87 = B
  _0 = Type
  _1 = Type
  _ty89 = Type
  _89 = B
  _89 = B
  _89 = B
  _1 = Type
  _89 = B
  _ty93 = Type
  _ty92 = Type
  _ty91 = Type
  _ty90 = Type
  _93 = B
  _92 = List
  _91 = B
  _93 = B
  _50 = _92
  _90 = V xs
  _91 = B
  _93 = B
  _91 = B
  _92 = List
  _90 = V xs
  _93 = B
  _91 = B
  _92 = List
  _90 = V xs
  _ty94 = Type
  _94 = List
  _94 = List
  _94 = List
  _ty95 = Type
  _95 = B
  _ty97 = Type
  _ty96 = Type
  _97 = B
  _96 = N
  _97 = B
  _97 = B
  _96 = N
  _ty98 = Type
  _98 = Type
  _ty100 = Type
  _ty99 = Type
  _98 = _100
  _1 = _100
  _99 = a
  _ty101 = Type
  _98 = _101
  _0 = _101

Solved metas: [_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _ty0, _ty1, _ty2, _ty3, _ty4, _ty5, _ty6, _ty7, _ty8, _ty9, _ty10, _ty11, _ty12, _ty13, _ty14, _ty15, _ty16, _ty17, _ty18, _ty19, _ty20, _ty21, _ty22, _ty23, _ty24, _ty25, _ty26, _ty27, _ty28, _ty29, _ty30, _ty31, _ty32, _ty33, _ty34, _ty35, _ty36, _ty37, _ty38, _ty39, _ty40, _ty41, _ty42, _ty43, _ty44, _ty45, _ty46, _ty47, _ty48, _ty49, _ty50, _ty51, _ty52, _ty53, _ty54, _ty55, _ty56, _ty57, _ty58, _ty59, _ty60, _ty61, _ty62, _ty63, _ty64, _ty65, _ty66, _ty67, _ty68, _ty69, _ty70, _ty71, _ty72, _ty73, _ty74, _ty75, _ty76, _ty77, _ty78, _ty79, _ty80, _ty81, _ty82, _ty83, _ty84, _ty85, _ty86, _ty87, _ty88, _ty89, _ty90, _ty91, _ty92, _ty93, _ty94, _ty95, _ty96, _ty97, _ty98, _ty99, _ty100, _ty101]

##############
# Elaborated #
##############

mutual {
  constructor/0 N : Type.
  
  constructor/0 Z : N.
  
  constructor/1 S : (_ :L N) -> N.
}

mutual {
  constructor/0 B : Type.
  
  constructor/0 T : B.
  
  constructor/0 F : B.
}

mutual {
  constructor/0 List : Type.
  
  constructor/2 Cons : (_ :L B) -> (_ :L List) -> List.
  
  constructor/0 Nil : List.
}

mutual {
  constructor/1 Maybe : (_ :L Type) -> Type.
  
  constructor/1 Nothing : (a :I Type) -> Maybe a.
  
  constructor/2 Just : (a :I Type) -> (_ :L a) -> Maybe a.
}

not : (_ : B) -> B {
  not T ~> F
  
  not F ~> T
}

mutual {
  constructor/3 Id : (a :I Type) -> (_ :L a) -> (_ :L a) -> Type.
  
  constructor/2 Refl : (a :I Type) -> (x :I a) -> Id a x x.
}

id : (a : Type) -> (_ : a) -> a {
  id  ~> \a : Type.
      \x : a.
        x
}

subst : (a : Type) -> (P : (x :L a) -> Type) -> (x : a) -> (y : a) -> (_ : Id a x y) -> (_ : P x) -> P y {
  forall (a : Type) (P : (_ : a) -> Type) (x : a).
  subst a P x [x] ({Refl} [a] [x]) ~> \w : P x.
      w
}

cong : (a : Type) -> (b : Type) -> (f : (x :L a) -> b) -> (x : a) -> (y : a) -> (_ : Id a x y) -> Id b (f x) (f y) {
  forall (a : Type) (b : Type) (f : (_ : a) -> b) (x : a).
  cong a b f x [x] [Refl a x] ~> Refl b (f x)
}

one : (x : B) -> List {
  forall (x : B).
  one x ~> Cons x Nil
}

app : (_ : List) -> (_ : List) -> List {
  forall (ys : List).
  app Nil ys ~> ys
  
  forall (x : B) (xs : List) (ys : List).
  app (Cons x xs) ys ~> Cons x (app xs ys)
}

appRightNeutral : (ys : List) -> Id List ys (app ys Nil) {
  appRightNeutral Nil ~> Refl List Nil
  
  forall (x : B) (xs : List).
  appRightNeutral (Cons x xs) ~> cong List List (Cons x) xs (app xs Nil) (appRightNeutral xs)
}

appAssoc : (xs : List) -> (ys : List) -> (zs : List) -> Id List (app (app xs ys) zs) (app xs (app ys zs)) {
  forall (ys : List) (zs : List).
  appAssoc Nil ys zs ~> Refl List (app ys zs)
  
  forall (x : B) (xs : List) (ys : List) (zs : List).
  appAssoc (Cons x xs) ys zs ~> cong List List (Cons x) (app (app xs ys) zs) (app xs (app ys zs)) (appAssoc xs ys zs)
}

mutual {
  constructor/1 Rev : (_ :L List) -> Type.
  
  constructor/0 RNil : Rev Nil.
  
  constructor/3 RSnoc : (xs :I List) -> (x :L B) -> (rxs :L Rev xs) -> Rev (app xs (one x)).
}

rev' : (xs : List) -> (rxs : Rev xs) -> (ys : List) -> Rev (app xs ys) {
  forall (xs : List) (rxs : Rev xs).
  rev' xs rxs Nil ~> subst List Rev xs (app xs Nil) (appRightNeutral xs) rxs
  
  forall (xs : List) (rxs : Rev xs) (y : B) (ys : List).
  rev' xs rxs (Cons y ys) ~> subst List Rev (app (app xs (one y)) ys) (app xs (Cons y ys)) (appAssoc xs (one y) ys) (rev' (app xs (one y)) (RSnoc xs y rxs) ys)
}

rev : (xs : List) -> Rev xs {
  forall (xs : List).
  rev xs ~> rev' Nil RNil xs
}

reverse' : (xs : List) -> (rxs : Rev xs) -> List {
  reverse' [Nil] RNil ~> Nil
  
  forall (xs : List) (x : B) (rxs : Rev xs).
  reverse' [app xs (one x)] (RSnoc xs x rxs) ~> Cons x (reverse' xs rxs)
}

reverse : (_ : List) -> List {
  forall (xs : List).
  reverse xs ~> reverse' xs (rev xs)
}

mutual {
  constructor/1 V : (_ :L List) -> Type.
  
  constructor/0 VNil : V Nil.
  
  constructor/1 VOne : (x :L B) -> V (Cons x Nil).
  
  constructor/4 VTwo : (x :L B) -> (xs :I List) -> (u :L V xs) -> (y :L B) -> V (Cons x (app xs (one y))).
}

length : (_ : List) -> N {
  length Nil ~> Z
  
  forall (x : B) (xs : List).
  length (Cons x xs) ~> S (length xs)
}

index : (_ : N) -> (_ : List) -> (_ : List) -> List {
  forall (xs : List) (ys : List).
  index Z xs ys ~> Nil
  
  forall (x : B) (xs : List) (y : B) (ys : List).
  index (S Z) (Cons x xs) (Cons y ys) ~> Cons x Nil
  
  forall (n : N) (x : B) (xs : List) (y : B) (ys : List).
  index (S (S n)) (Cons x xs) (Cons y ys) ~> Cons x (app (index n xs ys) (one y))
  
  forall (n : N).
  index (S n) Nil Nil ~> Nil
}

build : (n : N) -> (xs : List) -> (ys : List) -> V (index n xs ys) {
  forall (xs : List) (ys : List).
  build Z xs ys ~> VNil
  
  forall (x : B) (xs : List) (y : B) (ys : List).
  build (S Z) (Cons x xs) (Cons y ys) ~> VOne x
  
  forall (n : N) (x : B) (xs : List) (y : B) (ys : List).
  build (S (S n)) (Cons x xs) (Cons y ys) ~> VTwo x (index n xs ys) (build n xs ys) y
  
  forall (n : N).
  build (S n) Nil Nil ~> VNil
}

postulate eq : (xs : List) -> Id List (index (length xs) xs (reverse xs)) xs.

toV : (xs : List) -> V xs {
  forall (xs : List).
  toV xs ~> subst List V (index (length xs) xs (reverse xs)) xs (eq xs) (build (length xs) xs (reverse xs))
}

mutual {
  constructor/1 IsPalindrome : (_ :L List) -> Type.
  
  constructor/0 PNil : IsPalindrome Nil.
  
  constructor/1 POne : (b :L B) -> IsPalindrome (Cons b Nil).
  
  constructor/3 PTwo : (b :L B) -> (xs :I List) -> (pf :L IsPalindrome xs) -> IsPalindrome (Cons b (app xs (one b))).
}

decEq : (x : B) -> (y : B) -> Maybe (Id B x y) {
  decEq T T ~> Just (Id B T T) (Refl B T)
  
  decEq F F ~> Just (Id B F F) (Refl B F)
  
  decEq T F ~> Nothing (Id B T F)
  
  decEq F T ~> Nothing (Id B F T)
}

isPalinV' : (x : B) -> (y : B) -> (xs :I List) -> (v : V xs) -> (pfB : Maybe (Id B x y)) -> (pfV : Maybe (IsPalindrome xs)) -> Maybe (IsPalindrome (Cons x (app xs (one y)))) {
  forall (x : B) (xs : List) (v : V xs) (pfV : IsPalindrome xs).
  isPalinV' x [x] xs v (Just [Id B x x] [Refl B x]) (Just [IsPalindrome xs] pfV) ~> Just (IsPalindrome (Cons x (app xs (one x)))) (PTwo x xs pfV)
  
  forall (x : B) (y : B) (xs : List) (v : V xs) (pfB : Maybe (Id B x y)) (pfV : Maybe (IsPalindrome xs)).
  isPalinV' x y xs v pfB pfV ~> Nothing (IsPalindrome (Cons x (app xs (one y))))
}

isPalinV : (xs : List) -> (v : V xs) -> Maybe (IsPalindrome xs) {
  isPalinV [Nil] VNil ~> Just (IsPalindrome Nil) PNil
  
  forall (x : B).
  isPalinV [Cons x Nil] (VOne x) ~> Just (IsPalindrome (Cons x Nil)) (POne x)
  
  forall (x : B) (xs : List) (y : B) (v : V xs).
  isPalinV [Cons x (app xs (one y))] (VTwo x xs v y) ~> isPalinV' x y xs v (decEq x y) (isPalinV xs v)
}

isPalindrome : (xs : List) -> Maybe (IsPalindrome xs) {
  forall (xs : List).
  isPalindrome xs ~> isPalinV xs (toV xs)
}

genList : (_ : B) -> (_ : N) -> List {
  forall (b : B).
  genList b Z ~> Nil
  
  forall (b : B) (n : N).
  genList b (S n) ~> Cons b (genList (not b) n)
}

isJust : (a : Type) -> (x : Maybe a) -> B {
  forall (a : Type) (x : a).
  isJust a (Just [a] x) ~> T
  
  forall (a : Type).
  isJust a (Nothing [a]) ~> F
}

testList : List {
  testList  ~> Cons T (Cons F (Cons F (Cons T (Cons F (Cons F (Cons T Nil))))))
}

main : Maybe (IsPalindrome testList) {
  main  ~> isPalindrome testList
}

#############
# Evarified #
#############

mutual {
  constructor/0 N :9 Type.
  
  constructor/0 Z :57 N.
  
  constructor/1 S :40 (_ :L N) -> N.
}

mutual {
  constructor/0 B :0 Type.
  
  constructor/0 T :41 B.
  
  constructor/0 F :2 B.
}

mutual {
  constructor/0 List :7 Type.
  
  constructor/2 Cons :1 (_ :L B) -> (_ :L List) -> List.
  
  constructor/0 Nil :10 List.
}

mutual {
  constructor/1 Maybe :8 (_ :L Type) -> Type.
  
  constructor/1 Nothing :11 (a :I Type) -> Maybe a.
  
  constructor/2 Just :5 (a :I Type) -> (_ :L a) -> Maybe a.
}

not :520 (_ :521 B) -> B {
  not T ~> F
  
  not F ~> T
}

mutual {
  constructor/3 Id :3 (a :I Type) -> (_ :L a) -> (_ :L a) -> Type.
  
  constructor/2 Refl :35 (a :I Type) -> (x :I a) -> Id a x x.
}

id :300 (a :301 Type) -> (_ :302 a) -> a {
  id  ~> \a :303 Type.
      \x :304 a.
        x
}

subst :628 (a :629 Type) -> (P :630 (x :L a) -> Type) -> (x :631 a) -> (y :632 a) -> (_ :633 Id a x y) -> (_ :637 P x) -> P y {
  forall (a :643 Type) (P :641 (_ :642 a) -> Type) (x :640 a).
  subst a P x [x] ({Refl} [a] [x]) ~> \w :651 P x.
      w
}

cong :206 (a :207 Type) -> (b :208 Type) -> (f :209 (x :L a) -> b) -> (x :210 a) -> (y :211 a) -> (_ :212 Id a x y) -> Id b (f x) (f y) {
  forall (a :225 Type) (b :224 Type) (f :222 (_ :223 a) -> b) (x :221 a).
  cong a b f x [x] [Refl a x] ~> Refl b (f x)
}

one :524 (x :525 B) -> List {
  forall (x :526 B).
  one x ~> Cons x Nil
}

app :58 (_ :59 List) -> (_ :60 List) -> List {
  forall (ys :61 List).
  app Nil ys ~> ys
  
  forall (x :66 B) (xs :65 List) (ys :64 List).
  app (Cons x xs) ys ~> Cons x (app xs ys)
}

appRightNeutral :126 (ys :127 List) -> Id List ys (app ys Nil) {
  appRightNeutral Nil ~> Refl List Nil
  
  forall (x :137 B) (xs :136 List).
  appRightNeutral (Cons x xs) ~> cong List List (Cons x) xs (app xs Nil) (appRightNeutral xs)
}

appAssoc :75 (xs :76 List) -> (ys :77 List) -> (zs :78 List) -> Id List (app (app xs ys) zs) (app xs (app ys zs)) {
  forall (ys :91 List) (zs :90 List).
  appAssoc Nil ys zs ~> Refl List (app ys zs)
  
  forall (x :102 B) (xs :101 List) (ys :100 List) (zs :99 List).
  appAssoc (Cons x xs) ys zs ~> cong List List (Cons x) (app (app xs ys) zs) (app xs (app ys zs)) (appAssoc xs ys zs)
}

mutual {
  constructor/1 Rev :39 (_ :L List) -> Type.
  
  constructor/0 RNil :27 Rev Nil.
  
  constructor/3 RSnoc :29 (xs :I List) -> (x :L B) -> (rxs :L Rev xs) -> Rev (app xs (one x)).
}

rev' :538 (xs :539 List) -> (rxs :540 Rev xs) -> (ys :542 List) -> Rev (app xs ys) {
  forall (xs :548 List) (rxs :546 Rev xs).
  rev' xs rxs Nil ~> subst List Rev xs (app xs Nil) (appRightNeutral xs) rxs
  
  forall (xs :565 List) (rxs :563 Rev xs) (y :562 B) (ys :561 List).
  rev' xs rxs (Cons y ys) ~> subst List Rev (app (app xs (one y)) ys) (app xs (Cons y ys)) (appAssoc xs (one y) ys) (rev' (app xs (one y)) (RSnoc xs y rxs) ys)
}

rev :530 (xs :531 List) -> Rev xs {
  forall (xs :533 List).
  rev xs ~> rev' Nil RNil xs
}

reverse' :606 (xs :607 List) -> (rxs :608 Rev xs) -> List {
  reverse' [Nil] RNil ~> Nil
  
  forall (xs :615 List) (x :614 B) (rxs :612 Rev xs).
  reverse' [app xs (one x)] (RSnoc xs x rxs) ~> Cons x (reverse' xs rxs)
}

reverse :599 (_ :600 List) -> List {
  forall (xs :601 List).
  reverse xs ~> reverse' xs (rev xs)
}

mutual {
  constructor/1 V :42 (_ :L List) -> Type.
  
  constructor/0 VNil :43 V Nil.
  
  constructor/1 VOne :45 (x :L B) -> V (Cons x Nil).
  
  constructor/4 VTwo :49 (x :L B) -> (xs :I List) -> (u :L V xs) -> (y :L B) -> V (Cons x (app xs (one y))).
}

length :506 (_ :507 List) -> N {
  length Nil ~> Z
  
  forall (x :510 B) (xs :509 List).
  length (Cons x xs) ~> S (length xs)
}

index :305 (_ :306 N) -> (_ :307 List) -> (_ :308 List) -> List {
  forall (xs :310 List) (ys :309 List).
  index Z xs ys ~> Nil
  
  forall (x :317 B) (xs :316 List) (y :315 B) (ys :314 List).
  index (S Z) (Cons x xs) (Cons y ys) ~> Cons x Nil
  
  forall (n :332 N) (x :331 B) (xs :330 List) (y :329 B) (ys :328 List).
  index (S (S n)) (Cons x xs) (Cons y ys) ~> Cons x (app (index n xs ys) (one y))
  
  forall (n :350 N).
  index (S n) Nil Nil ~> Nil
}

build :151 (n :152 N) -> (xs :153 List) -> (ys :154 List) -> V (index n xs ys) {
  forall (xs :160 List) (ys :159 List).
  build Z xs ys ~> VNil
  
  forall (x :167 B) (xs :166 List) (y :165 B) (ys :164 List).
  build (S Z) (Cons x xs) (Cons y ys) ~> VOne x
  
  forall (n :181 N) (x :180 B) (xs :179 List) (y :178 B) (ys :177 List).
  build (S (S n)) (Cons x xs) (Cons y ys) ~> VTwo x (index n xs ys) (build n xs ys) y
  
  forall (n :201 N).
  build (S n) Nil Nil ~> VNil
}

postulate eq :274 (xs :275 List) -> Id List (index (length xs) xs (reverse xs)) xs.

toV :668 (xs :669 List) -> V xs {
  forall (xs :671 List).
  toV xs ~> subst List V (index (length xs) xs (reverse xs)) xs (eq xs) (build (length xs) xs (reverse xs))
}

mutual {
  constructor/1 IsPalindrome :4 (_ :L List) -> Type.
  
  constructor/0 PNil :13 IsPalindrome Nil.
  
  constructor/1 POne :15 (b :L B) -> IsPalindrome (Cons b Nil).
  
  constructor/3 PTwo :19 (b :L B) -> (xs :I List) -> (pf :L IsPalindrome xs) -> IsPalindrome (Cons b (app xs (one b))).
}

decEq :237 (x :238 B) -> (y :239 B) -> Maybe (Id B x y) {
  decEq T T ~> Just (Id B T T) (Refl B T)
  
  decEq F F ~> Just (Id B F F) (Refl B F)
  
  decEq T F ~> Nothing (Id B T F)
  
  decEq F T ~> Nothing (Id B F T)
}

isPalinV' :418 (x :419 B) -> (y :420 B) -> (xs :I List) -> (v :421 V xs) -> (pfB :423 Maybe (Id B x y)) -> (pfV :428 Maybe (IsPalindrome xs)) -> Maybe (IsPalindrome (Cons x (app xs (one y)))) {
  forall (x :443 B) (xs :442 List) (v :440 V xs) (pfV :438 IsPalindrome xs).
  isPalinV' x [x] xs v (Just [Id B x x] [Refl B x]) (Just [IsPalindrome xs] pfV) ~> Just (IsPalindrome (Cons x (app xs (one x)))) (PTwo x xs pfV)
  
  forall (x :483 B) (y :482 B) (xs :481 List) (v :479 V xs) (pfB :474 Maybe (Id B x y)) (pfV :471 Maybe (IsPalindrome xs)).
  isPalinV' x y xs v pfB pfV ~> Nothing (IsPalindrome (Cons x (app xs (one y))))
}

isPalinV :369 (xs :370 List) -> (v :371 V xs) -> Maybe (IsPalindrome xs) {
  isPalinV [Nil] VNil ~> Just (IsPalindrome Nil) PNil
  
  forall (x :380 B).
  isPalinV [Cons x Nil] (VOne x) ~> Just (IsPalindrome (Cons x Nil)) (POne x)
  
  forall (x :396 B) (xs :395 List) (y :394 B) (v :392 V xs).
  isPalinV [Cons x (app xs (one y))] (VTwo x xs v y) ~> isPalinV' x y xs v (decEq x y) (isPalinV xs v)
}

isPalindrome :497 (xs :498 List) -> Maybe (IsPalindrome xs) {
  forall (xs :501 List).
  isPalindrome xs ~> isPalinV xs (toV xs)
}

genList :284 (_ :285 B) -> (_ :286 N) -> List {
  forall (b :287 B).
  genList b Z ~> Nil
  
  forall (b :291 B) (n :290 N).
  genList b (S n) ~> Cons b (genList (not b) n)
}

isJust :355 (a :356 Type) -> (x :357 Maybe a) -> B {
  forall (a :360 Type) (x :359 a).
  isJust a (Just [a] x) ~> T
  
  forall (a :365 Type).
  isJust a (Nothing [a]) ~> F
}

testList :653 List {
  testList  ~> Cons T (Cons F (Cons F (Cons T (Cons F (Cons F (Cons T Nil))))))
}

main :516 Maybe (IsPalindrome testList) {
  main  ~> isPalindrome testList
}
inferring  mutual {
    constructor/0 N :9 Type.
    
    constructor/0 Z :57 N.
    
    constructor/1 S :40 (_ :L N) -> N.
  }

  
  
  variance of evars:
    covariant: []
    contravariant: []
  mutual {
    constructor/0 N :I Type.
    
    constructor/0 Z :I N.
    
    constructor/1 S :I (_ :L N) -> N.
  }

inferring  mutual {
    constructor/0 B :0 Type.
    
    constructor/0 T :41 B.
    
    constructor/0 F :2 B.
  }

  
  
  variance of evars:
    covariant: []
    contravariant: []
  mutual {
    constructor/0 B :I Type.
    
    constructor/0 T :I B.
    
    constructor/0 F :I B.
  }

inferring  mutual {
    constructor/0 List :7 Type.
    
    constructor/2 Cons :1 (_ :L B) -> (_ :L List) -> List.
    
    constructor/0 Nil :10 List.
  }

  
  
  variance of evars:
    covariant: []
    contravariant: []
  mutual {
    constructor/0 List :I Type.
    
    constructor/2 Cons :I (_ :L B) -> (_ :L List) -> List.
    
    constructor/0 Nil :I List.
  }

inferring  mutual {
    constructor/1 Maybe :8 (_ :L Type) -> Type.
    
    constructor/1 Nothing :11 (a :I Type) -> Maybe a.
    
    constructor/2 Just :5 (a :I Type) -> (_ :L a) -> Maybe a.
  }

  inferred constraints: 
    L ~ 12
    L ~ 6
  
  
  variance of evars:
    covariant: []
    contravariant: []
  mutual {
    constructor/1 Maybe :I (_ :L Type) -> Type.
    
    constructor/1 Nothing :I (a :I Type) -> Maybe a.
    
    constructor/2 Just :I (a :I Type) -> (_ :L a) -> Maybe a.
  }

inferring  not :520 (_ :521 B) -> B {
    not T ~> F
    
    not F ~> T
  }

  inferred constraints: 
    521 ~ 522
    product [521] ≥ sum
      product [L]
    521 ~ 523
    product [521] ≥ sum
      product [L]
  
  
  variance of evars:
    covariant: []
    contravariant: [521]
  not :I (_ :L B) -> B {
    not T ~> F
    
    not F ~> T
  }

inferring  mutual {
    constructor/3 Id :3 (a :I Type) -> (_ :L a) -> (_ :L a) -> Type.
    
    constructor/2 Refl :35 (a :I Type) -> (x :I a) -> Id a x x.
  }

  inferred constraints: 
    I ~ 38
    L ~ 37
    L ~ 36
  
  
  variance of evars:
    covariant: []
    contravariant: []
  mutual {
    constructor/3 Id :I (a :I Type) -> (_ :L a) -> (_ :L a) -> Type.
    
    constructor/2 Refl :I (a :I Type) -> (x :I a) -> Id a x x.
  }

inferring  id :300 (a :301 Type) -> (_ :302 a) -> a {
    id  ~> \a :303 Type.
        \x :304 a.
          x
  }

  inferred constraints: 
    303 ≥ sum
    304 ≥ sum
      product []
    303 ~ 301
    304 ~ 302
  
  
  variance of evars:
    covariant: []
    contravariant: [301, 302]
  id :I (a :I Type) -> (_ :L a) -> a {
    id  ~> \a :I Type.
        \x :L a.
          x
  }

inferring  subst :628 (a :629 Type) -> (P :630 (x :L a) -> Type) -> (x :631 a) -> (y :632 a) -> (_ :633 Id a x y) -> (_ :637 P x) -> P y {
    forall (a :643 Type) (P :641 (_ :642 a) -> Type) (x :640 a).
    subst a P x [x] ({Refl} [a] [x]) ~> \w :651 P x.
        w
  }

  inferred constraints: 
    I ~ 636
    L ~ 635
    L ~ 634
    L ~ 638
    L ~ 639
    643 ~ product [629]
    641 ~ product [630]
    640 ~ product [631]
    629 ~ 644
    630 ~ 645
    L ~ 642
    631 ~ 646
    632 ~ 647
    633 ~ 648
    product [633] ≥ sum
      product [I]
    I ~ 649
    I ~ 650
    634 ~ L
    635 ~ L
    636 ~ I
    643 ≥ sum
    641 ≥ sum
    640 ≥ sum
    642 ~ 652
    651 ≥ sum
      product []
    651 ~ 637
    652 ~ 638
    652 ~ 639
  
  
  variance of evars:
    covariant: []
    contravariant: [629, 630, 631, 632, 633, 637]
  subst :I (a :I Type) -> (P :I (x :L a) -> Type) -> (x :I a) -> (y :I a) -> (_ :I Id a x y) -> (_ :L P x) -> P y {
    forall (a :I Type) (P :I (_ :L a) -> Type) (x :I a).
    subst a P x [x] ({Refl} [a] [x]) ~> \w :L P x.
        w
  }

inferring  cong :206 (a :207 Type) -> (b :208 Type) -> (f :209 (x :L a) -> b) -> (x :210 a) -> (y :211 a) -> (_ :212 Id a x y) -> Id b (f x) (f y) {
    forall (a :225 Type) (b :224 Type) (f :222 (_ :223 a) -> b) (x :221 a).
    cong a b f x [x] [Refl a x] ~> Refl b (f x)
  }

  inferred constraints: 
    I ~ 215
    L ~ 214
    L ~ 213
    I ~ 218
    L ~ 217
    L ~ 219
    L ~ 216
    L ~ 220
    225 ~ product [207]
    224 ~ product [208]
    222 ~ product [209]
    221 ~ product [210]
    207 ~ 226
    208 ~ 227
    209 ~ 228
    L ~ 223
    210 ~ 229
    211 ~ 230
    212 ~ 231
    I ~ 233
    I ~ 232
    213 ~ L
    214 ~ L
    215 ~ I
    225 ≥ sum
    224 ≥ sum
      product [I]
    222 ≥ sum
      product [I]
    221 ≥ sum
      product [223, I]
    I ~ 235
    I ~ 234
    223 ~ 236
    L ~ 216
    L ~ 217
    I ~ 218
  
  deferred equalities: 
    217 -> f x ~ f x
    216 -> f x ~ f x
  
  variance of evars:
    covariant: []
    contravariant: [207, 208, 209, 210, 211, 212]
  -> iteration 1
    f x ~ f x
    f x ~ f x

  cong :I (a :I Type) -> (b :I Type) -> (f :I (x :L a) -> b) -> (x :I a) -> (y :I a) -> (_ :I Id a x y) -> Id b (f x) (f y) {
    forall (a :I Type) (b :I Type) (f :I (_ :L a) -> b) (x :I a).
    cong a b f x [x] [Refl a x] ~> Refl b (f x)
  }

inferring  one :524 (x :525 B) -> List {
    forall (x :526 B).
    one x ~> Cons x Nil
  }

  inferred constraints: 
    526 ~ product [525]
    525 ~ 527
    526 ≥ sum
      product [L]
    L ~ 529
    L ~ 528
  
  
  variance of evars:
    covariant: []
    contravariant: [525]
  one :I (x :L B) -> List {
    forall (x :L B).
    one x ~> Cons x Nil
  }

inferring  app :58 (_ :59 List) -> (_ :60 List) -> List {
    forall (ys :61 List).
    app Nil ys ~> ys
    
    forall (x :66 B) (xs :65 List) (ys :64 List).
    app (Cons x xs) ys ~> Cons x (app xs ys)
  }

  inferred constraints: 
    61 ~ product [60]
    59 ~ 62
    product [59] ≥ sum
      product [L]
    60 ~ 63
    61 ≥ sum
      product []
    66 ~ product [L, 59]
    65 ~ product [L, 59]
    64 ~ product [60]
    59 ~ 67
    product [59] ≥ sum
      product [L]
    L ~ 68
    L ~ 69
    60 ~ 70
    66 ≥ sum
      product [L]
    65 ≥ sum
      product [59, L]
    64 ≥ sum
      product [60, L]
    L ~ 72
    L ~ 71
    59 ~ 74
    60 ~ 73
  
  
  variance of evars:
    covariant: []
    contravariant: [59, 60]
  app :I (_ :L List) -> (_ :L List) -> List {
    forall (ys :L List).
    app Nil ys ~> ys
    
    forall (x :L B) (xs :L List) (ys :L List).
    app (Cons x xs) ys ~> Cons x (app xs ys)
  }

inferring  appRightNeutral :126 (ys :127 List) -> Id List ys (app ys Nil) {
    appRightNeutral Nil ~> Refl List Nil
    
    forall (x :137 B) (xs :136 List).
    appRightNeutral (Cons x xs) ~> cong List List (Cons x) xs (app xs Nil) (appRightNeutral xs)
  }

  inferred constraints: 
    I ~ 130
    L ~ 129
    L ~ 128
    L ~ 132
    L ~ 131
    127 ~ 133
    product [127] ≥ sum
      product [L]
    I ~ 135
    I ~ 134
    L ~ 128
    L ~ 129
    I ~ 130
    137 ~ product [L, 127]
    136 ~ product [L, 127]
    127 ~ 138
    product [127] ≥ sum
      product [L]
    L ~ 139
    L ~ 140
    137 ≥ sum
      product [L, I]
    136 ≥ sum
      product [I]
      product [L, I]
      product [127, I]
    I ~ 146
    I ~ 145
    I ~ 144
    L ~ 147
    I ~ 143
    I ~ 142
    L ~ 149
    L ~ 148
    I ~ 141
    127 ~ 150
    L ~ 128
    L ~ 129
    I ~ 130
    L ~ 128
    L ~ 129
    I ~ 130
  
  deferred equalities: 
    128 -> app Nil Nil ~ Nil
    128 -> app xs Nil ~ app xs Nil
    129 -> Cons x xs ~ Cons x xs
    128 -> app (Cons x xs) Nil ~ Cons x (app xs Nil)
  
  variance of evars:
    covariant: []
    contravariant: [127]
  -> iteration 1
    app Nil Nil ~ Nil
    app xs Nil ~ app xs Nil
    Cons x xs ~ Cons x xs
    app (Cons x xs) Nil ~ Cons x (app xs Nil)

  appRightNeutral :I (ys :R List) -> Id List ys (app ys Nil) {
    appRightNeutral Nil ~> Refl List Nil
    
    forall (x :R B) (xs :R List).
    appRightNeutral (Cons x xs) ~> cong List List (Cons x) xs (app xs Nil) (appRightNeutral xs)
  }

inferring  appAssoc :75 (xs :76 List) -> (ys :77 List) -> (zs :78 List) -> Id List (app (app xs ys) zs) (app xs (app ys zs)) {
    forall (ys :91 List) (zs :90 List).
    appAssoc Nil ys zs ~> Refl List (app ys zs)
    
    forall (x :102 B) (xs :101 List) (ys :100 List) (zs :99 List).
    appAssoc (Cons x xs) ys zs ~> cong List List (Cons x) (app (app xs ys) zs) (app xs (app ys zs)) (appAssoc xs ys zs)
  }

  inferred constraints: 
    I ~ 81
    L ~ 80
    L ~ 83
    L ~ 85
    L ~ 84
    L ~ 82
    L ~ 79
    L ~ 87
    L ~ 86
    L ~ 89
    L ~ 88
    91 ~ product [77]
    90 ~ product [78]
    76 ~ 92
    product [76] ≥ sum
      product [L]
    77 ~ 93
    78 ~ 94
    91 ≥ sum
      product [L, I]
    90 ≥ sum
      product [L, I]
    I ~ 96
    I ~ 95
    L ~ 98
    L ~ 97
    L ~ 79
    L ~ 80
    I ~ 81
    102 ~ product [L, 76]
    101 ~ product [L, 76]
    100 ~ product [77]
    99 ~ product [78]
    76 ~ 103
    product [76] ≥ sum
      product [L]
    L ~ 104
    L ~ 105
    77 ~ 106
    78 ~ 107
    102 ≥ sum
      product [L, I]
    101 ≥ sum
      product [L, L, I]
      product [L, I]
      product [76, I]
    100 ≥ sum
      product [L, L, I]
      product [L, L, I]
      product [77, I]
    99 ≥ sum
      product [L, I]
      product [L, L, I]
      product [78, I]
    I ~ 113
    I ~ 112
    I ~ 111
    L ~ 114
    I ~ 110
    L ~ 116
    L ~ 118
    L ~ 117
    L ~ 115
    I ~ 109
    L ~ 120
    L ~ 119
    L ~ 122
    L ~ 121
    I ~ 108
    76 ~ 125
    77 ~ 124
    78 ~ 123
    L ~ 79
    L ~ 80
    I ~ 81
    L ~ 79
    L ~ 80
    I ~ 81
  
  deferred equalities: 
    80 -> app (app Nil ys) zs ~ app ys zs
    79 -> app Nil (app ys zs) ~ app ys zs
    80 -> app (app xs ys) zs ~ app (app xs ys) zs
    79 -> app xs (app ys zs) ~ app xs (app ys zs)
    80 -> app (app (Cons x xs) ys) zs ~ Cons x (app (app xs ys) zs)
    79 -> app (Cons x xs) (app ys zs) ~ Cons x (app xs (app ys zs))
  
  variance of evars:
    covariant: []
    contravariant: [76, 77, 78]
  -> iteration 1
    app (app Nil ys) zs ~ app ys zs
    app Nil (app ys zs) ~ app ys zs
    app (app xs ys) zs ~ app (app xs ys) zs
    app xs (app ys zs) ~ app xs (app ys zs)
    app (app (Cons x xs) ys) zs ~ Cons x (app (app xs ys) zs)
    app (Cons x xs) (app ys zs) ~ Cons x (app xs (app ys zs))

  -> iteration 2
    app Nil ys ~ ys
    app xs ys ~ app xs ys
    app ys zs ~ app ys zs

  appAssoc :I (xs :R List) -> (ys :I List) -> (zs :I List) -> Id List (app (app xs ys) zs) (app xs (app ys zs)) {
    forall (ys :I List) (zs :I List).
    appAssoc Nil ys zs ~> Refl List (app ys zs)
    
    forall (x :R B) (xs :R List) (ys :I List) (zs :I List).
    appAssoc (Cons x xs) ys zs ~> cong List List (Cons x) (app (app xs ys) zs) (app xs (app ys zs)) (appAssoc xs ys zs)
  }

inferring  mutual {
    constructor/1 Rev :39 (_ :L List) -> Type.
    
    constructor/0 RNil :27 Rev Nil.
    
    constructor/3 RSnoc :29 (xs :I List) -> (x :L B) -> (rxs :L Rev xs) -> Rev (app xs (one x)).
  }

  inferred constraints: 
    L ~ 28
    L ~ 30
    L ~ 31
    L ~ 33
    L ~ 32
    L ~ 34
  
  
  variance of evars:
    covariant: []
    contravariant: []
  mutual {
    constructor/1 Rev :I (_ :L List) -> Type.
    
    constructor/0 RNil :I Rev Nil.
    
    constructor/3 RSnoc :I (xs :I List) -> (x :L B) -> (rxs :L Rev xs) -> Rev (app xs (one x)).
  }

inferring  rev' :538 (xs :539 List) -> (rxs :540 Rev xs) -> (ys :542 List) -> Rev (app xs ys) {
    forall (xs :548 List) (rxs :546 Rev xs).
    rev' xs rxs Nil ~> subst List Rev xs (app xs Nil) (appRightNeutral xs) rxs
    
    forall (xs :565 List) (rxs :563 Rev xs) (y :562 B) (ys :561 List).
    rev' xs rxs (Cons y ys) ~> subst List Rev (app (app xs (one y)) ys) (app xs (Cons y ys)) (appAssoc xs (one y) ys) (rev' (app xs (one y)) (RSnoc xs y rxs) ys)
  }

  inferred constraints: 
    L ~ 541
    L ~ 543
    L ~ 545
    L ~ 544
    L ~ 547
    548 ~ product [539]
    546 ~ product [540]
    539 ~ 549
    540 ~ 550
    541 ~ 547
    542 ~ 551
    product [542] ≥ sum
      product [L]
    548 ≥ sum
      product [I]
      product [L, I]
      product [R, I]
    546 ≥ sum
      product [L]
    I ~ 557
    I ~ 556
    I ~ 555
    I ~ 554
    L ~ 559
    L ~ 558
    I ~ 553
    R ~ 560
    558 ~ L
    559 ~ L
    L ~ 552
    L ~ 547
    L ~ 543
    L ~ 564
    565 ~ product [539]
    563 ~ product [540]
    562 ~ product [L, 542]
    561 ~ product [L, 542]
    539 ~ 566
    540 ~ 567
    541 ~ 564
    542 ~ 568
    product [542] ≥ sum
      product [L]
    L ~ 569
    L ~ 570
    565 ≥ sum
      product [L, L, I]
      product [L, I]
      product [R, I]
      product [L, 539, L]
      product [I, 540, L]
    563 ≥ sum
      product [L, 540, L]
    562 ≥ sum
      product [L, L, L, I]
      product [L, L, I]
      product [L, I, I]
      product [L, L, 539, L]
      product [L, 540, L]
    561 ≥ sum
      product [L, I]
      product [L, L, I]
      product [I, I]
      product [542, L]
    I ~ 576
    I ~ 575
    I ~ 574
    L ~ 578
    L ~ 580
    L ~ 579
    L ~ 581
    L ~ 577
    I ~ 573
    L ~ 583
    L ~ 582
    L ~ 585
    L ~ 584
    I ~ 572
    R ~ 588
    I ~ 587
    L ~ 589
    I ~ 586
    577 ~ L
    578 ~ L
    579 ~ L
    580 ~ L
    582 ~ L
    583 ~ L
    584 ~ L
    585 ~ L
    L ~ 571
    539 ~ 592
    L ~ 594
    L ~ 593
    L ~ 595
    540 ~ 591
    I ~ 598
    L ~ 597
    L ~ 596
    L ~ 564
    541 ~ L
    593 ~ L
    594 ~ L
    542 ~ 590
    L ~ 543
    L ~ 543
  
  deferred equalities: 
    543 -> app xs Nil ~ app xs Nil
    543 -> app (app xs (one y)) ys ~ app (app xs (one y)) ys
    543 -> app xs (Cons y ys) ~ app xs (Cons y ys)
  
  variance of evars:
    covariant: []
    contravariant: [539, 540, 542]
  -> iteration 1
    app xs Nil ~ app xs Nil
    app (app xs (one y)) ys ~ app (app xs (one y)) ys
    app xs (Cons y ys) ~ app xs (Cons y ys)

  -> iteration 2
    app xs (one y) ~ app xs (one y)
    Cons y ys ~ Cons y ys

  -> iteration 3
    one y ~ one y

  rev' :I (xs :I List) -> (rxs :L Rev xs) -> (ys :L List) -> Rev (app xs ys) {
    forall (xs :I List) (rxs :L Rev xs).
    rev' xs rxs Nil ~> subst List Rev xs (app xs Nil) (appRightNeutral xs) rxs
    
    forall (xs :I List) (rxs :L Rev xs) (y :L B) (ys :L List).
    rev' xs rxs (Cons y ys) ~> subst List Rev (app (app xs (one y)) ys) (app xs (Cons y ys)) (appAssoc xs (one y) ys) (rev' (app xs (one y)) (RSnoc xs y rxs) ys)
  }

inferring  rev :530 (xs :531 List) -> Rev xs {
    forall (xs :533 List).
    rev xs ~> rev' Nil RNil xs
  }

  inferred constraints: 
    L ~ 532
    533 ~ product [531]
    531 ~ 534
    533 ≥ sum
      product [L]
    I ~ 537
    L ~ 536
    L ~ 535
    L ~ 532
  
  deferred equalities: 
    532 -> xs ~ app Nil xs
  
  variance of evars:
    covariant: []
    contravariant: [531]
  -> iteration 1
    xs ~ app Nil xs

  rev :I (xs :L List) -> Rev xs {
    forall (xs :L List).
    rev xs ~> rev' Nil RNil xs
  }

inferring  reverse' :606 (xs :607 List) -> (rxs :608 Rev xs) -> List {
    reverse' [Nil] RNil ~> Nil
    
    forall (xs :615 List) (x :614 B) (rxs :612 Rev xs).
    reverse' [app xs (one x)] (RSnoc xs x rxs) ~> Cons x (reverse' xs rxs)
  }

  inferred constraints: 
    L ~ 609
    607 ~ 610
    608 ~ 611
    product [608] ≥ sum
      product [L]
    609 ~ L
    L ~ 613
    615 ~ product [I, 608]
    614 ~ product [L, 608]
    612 ~ product [L, 608]
    607 ~ 616
    L ~ 618
    L ~ 617
    L ~ 619
    608 ~ 620
    product [608] ≥ sum
      product [L]
    I ~ 621
    L ~ 622
    L ~ 623
    L ~ 613
    609 ~ L
    617 ~ L
    618 ~ L
    615 ≥ sum
      product [607, L]
    614 ≥ sum
      product [L]
    612 ≥ sum
      product [608, L]
    L ~ 625
    L ~ 624
    607 ~ 627
    608 ~ 626
    609 ~ 613
  
  
  variance of evars:
    covariant: []
    contravariant: [607, 608]
  reverse' :I (xs :I List) -> (rxs :L Rev xs) -> List {
    reverse' [Nil] RNil ~> Nil
    
    forall (xs :I List) (x :L B) (rxs :L Rev xs).
    reverse' [app xs (one x)] (RSnoc xs x rxs) ~> Cons x (reverse' xs rxs)
  }

inferring  reverse :599 (_ :600 List) -> List {
    forall (xs :601 List).
    reverse xs ~> reverse' xs (rev xs)
  }

  inferred constraints: 
    601 ~ product [600]
    600 ~ 602
    601 ≥ sum
      product [I]
      product [L, L]
    I ~ 604
    L ~ 603
    L ~ 605
  
  
  variance of evars:
    covariant: []
    contravariant: [600]
  reverse :I (_ :L List) -> List {
    forall (xs :L List).
    reverse xs ~> reverse' xs (rev xs)
  }

inferring  mutual {
    constructor/1 V :42 (_ :L List) -> Type.
    
    constructor/0 VNil :43 V Nil.
    
    constructor/1 VOne :45 (x :L B) -> V (Cons x Nil).
    
    constructor/4 VTwo :49 (x :L B) -> (xs :I List) -> (u :L V xs) -> (y :L B) -> V (Cons x (app xs (one y))).
  }

  inferred constraints: 
    L ~ 44
    L ~ 46
    L ~ 48
    L ~ 47
    L ~ 50
    L ~ 51
    L ~ 53
    L ~ 52
    L ~ 55
    L ~ 54
    L ~ 56
  
  
  variance of evars:
    covariant: []
    contravariant: []
  mutual {
    constructor/1 V :I (_ :L List) -> Type.
    
    constructor/0 VNil :I V Nil.
    
    constructor/1 VOne :I (x :L B) -> V (Cons x Nil).
    
    constructor/4 VTwo :I (x :L B) -> (xs :I List) -> (u :L V xs) -> (y :L B) -> V (Cons x (app xs (one y))).
  }

inferring  length :506 (_ :507 List) -> N {
    length Nil ~> Z
    
    forall (x :510 B) (xs :509 List).
    length (Cons x xs) ~> S (length xs)
  }

  inferred constraints: 
    507 ~ 508
    product [507] ≥ sum
      product [L]
    510 ~ product [L, 507]
    509 ~ product [L, 507]
    507 ~ 511
    product [507] ≥ sum
      product [L]
    L ~ 512
    L ~ 513
    510 ≥ sum
    509 ≥ sum
      product [507, L]
    L ~ 514
    507 ~ 515
  
  
  variance of evars:
    covariant: []
    contravariant: [507]
  length :I (_ :R List) -> N {
    length Nil ~> Z
    
    forall (x :R B) (xs :R List).
    length (Cons x xs) ~> S (length xs)
  }

inferring  index :305 (_ :306 N) -> (_ :307 List) -> (_ :308 List) -> List {
    forall (xs :310 List) (ys :309 List).
    index Z xs ys ~> Nil
    
    forall (x :317 B) (xs :316 List) (y :315 B) (ys :314 List).
    index (S Z) (Cons x xs) (Cons y ys) ~> Cons x Nil
    
    forall (n :332 N) (x :331 B) (xs :330 List) (y :329 B) (ys :328 List).
    index (S (S n)) (Cons x xs) (Cons y ys) ~> Cons x (app (index n xs ys) (one y))
    
    forall (n :350 N).
    index (S n) Nil Nil ~> Nil
  }

  inferred constraints: 
    310 ~ product [307]
    309 ~ product [308]
    306 ~ 311
    product [306] ≥ sum
      product [L]
    307 ~ 312
    308 ~ 313
    310 ≥ sum
    309 ≥ sum
    317 ~ product [L, 307]
    316 ~ product [L, 307]
    315 ~ product [L, 308]
    314 ~ product [L, 308]
    306 ~ 318
    product [306] ≥ sum
      product [L]
    L ~ 319
    product [L, 306] ≥ sum
      product [L]
    307 ~ 320
    product [307] ≥ sum
      product [L]
    L ~ 321
    L ~ 322
    308 ~ 323
    product [308] ≥ sum
      product [L]
    L ~ 324
    L ~ 325
    317 ≥ sum
      product [L]
    316 ≥ sum
    315 ≥ sum
    314 ≥ sum
    L ~ 327
    L ~ 326
    332 ~ product [L, L, 306]
    331 ~ product [L, 307]
    330 ~ product [L, 307]
    329 ~ product [L, 308]
    328 ~ product [L, 308]
    306 ~ 333
    product [306] ≥ sum
      product [L]
    L ~ 334
    product [L, 306] ≥ sum
      product [L]
    L ~ 335
    307 ~ 336
    product [307] ≥ sum
      product [L]
    L ~ 337
    L ~ 338
    308 ~ 339
    product [308] ≥ sum
      product [L]
    L ~ 340
    L ~ 341
    332 ≥ sum
      product [306, L, L]
    331 ≥ sum
      product [L]
    330 ≥ sum
      product [307, L, L]
    329 ≥ sum
      product [L, L, L]
    328 ≥ sum
      product [308, L, L]
    L ~ 343
    L ~ 342
    L ~ 345
    306 ~ 348
    307 ~ 347
    308 ~ 346
    L ~ 344
    L ~ 349
    350 ~ product [L, 306]
    306 ~ 351
    product [306] ≥ sum
      product [L]
    L ~ 352
    307 ~ 353
    product [307] ≥ sum
      product [L]
    308 ~ 354
    product [308] ≥ sum
      product [L]
    350 ≥ sum
  
  
  variance of evars:
    covariant: []
    contravariant: [306, 307, 308]
  index :I (_ :R N) -> (_ :R List) -> (_ :R List) -> List {
    forall (xs :R List) (ys :R List).
    index Z xs ys ~> Nil
    
    forall (x :R B) (xs :R List) (y :R B) (ys :R List).
    index (S Z) (Cons x xs) (Cons y ys) ~> Cons x Nil
    
    forall (n :R N) (x :R B) (xs :R List) (y :R B) (ys :R List).
    index (S (S n)) (Cons x xs) (Cons y ys) ~> Cons x (app (index n xs ys) (one y))
    
    forall (n :R N).
    index (S n) Nil Nil ~> Nil
  }

inferring  build :151 (n :152 N) -> (xs :153 List) -> (ys :154 List) -> V (index n xs ys) {
    forall (xs :160 List) (ys :159 List).
    build Z xs ys ~> VNil
    
    forall (x :167 B) (xs :166 List) (y :165 B) (ys :164 List).
    build (S Z) (Cons x xs) (Cons y ys) ~> VOne x
    
    forall (n :181 N) (x :180 B) (xs :179 List) (y :178 B) (ys :177 List).
    build (S (S n)) (Cons x xs) (Cons y ys) ~> VTwo x (index n xs ys) (build n xs ys) y
    
    forall (n :201 N).
    build (S n) Nil Nil ~> VNil
  }

  inferred constraints: 
    L ~ 155
    R ~ 158
    R ~ 157
    R ~ 156
    160 ~ product [153]
    159 ~ product [154]
    152 ~ 161
    product [152] ≥ sum
      product [L]
    153 ~ 162
    154 ~ 163
    160 ≥ sum
    159 ≥ sum
    L ~ 155
    167 ~ product [L, 153]
    166 ~ product [L, 153]
    165 ~ product [L, 154]
    164 ~ product [L, 154]
    152 ~ 168
    product [152] ≥ sum
      product [L]
    L ~ 169
    product [L, 152] ≥ sum
      product [L]
    153 ~ 170
    product [153] ≥ sum
      product [L]
    L ~ 171
    L ~ 172
    154 ~ 173
    product [154] ≥ sum
      product [L]
    L ~ 174
    L ~ 175
    167 ≥ sum
      product [L]
    166 ≥ sum
    165 ≥ sum
    164 ≥ sum
    L ~ 176
    L ~ 155
    181 ~ product [L, L, 152]
    180 ~ product [L, 153]
    179 ~ product [L, 153]
    178 ~ product [L, 154]
    177 ~ product [L, 154]
    152 ~ 182
    product [152] ≥ sum
      product [L]
    L ~ 183
    product [L, 152] ≥ sum
      product [L]
    L ~ 184
    153 ~ 185
    product [153] ≥ sum
      product [L]
    L ~ 186
    L ~ 187
    154 ~ 188
    product [154] ≥ sum
      product [L]
    L ~ 189
    L ~ 190
    181 ≥ sum
      product [R, I]
      product [152, L]
    180 ≥ sum
      product [L]
    179 ≥ sum
      product [R, I]
      product [153, L]
    178 ≥ sum
      product [L]
    177 ≥ sum
      product [R, I]
      product [154, L]
    L ~ 194
    I ~ 193
    R ~ 197
    R ~ 196
    R ~ 195
    L ~ 192
    152 ~ 200
    153 ~ 199
    154 ~ 198
    L ~ 155
    L ~ 191
    L ~ 155
    201 ~ product [L, 152]
    152 ~ 202
    product [152] ≥ sum
      product [L]
    L ~ 203
    153 ~ 204
    product [153] ≥ sum
      product [L]
    154 ~ 205
    product [154] ≥ sum
      product [L]
    201 ≥ sum
    L ~ 155
  
  deferred equalities: 
    155 -> index Z xs ys ~ Nil
    155 -> index (S Z) (Cons x xs) (Cons y ys) ~ Cons x Nil
    155 -> index n xs ys ~ index n xs ys
    155 -> index (S (S n)) (Cons x xs) (Cons y ys) ~ Cons x (app (index n xs ys) (one y))
    155 -> index (S n) Nil Nil ~ Nil
  
  variance of evars:
    covariant: []
    contravariant: [152, 153, 154]
  -> iteration 1
    index Z xs ys ~ Nil
    index (S Z) (Cons x xs) (Cons y ys) ~ Cons x Nil
    index n xs ys ~ index n xs ys
    index (S (S n)) (Cons x xs) (Cons y ys) ~ Cons x (app (index n xs ys) (one y))
    index (S n) Nil Nil ~ Nil

  build :I (n :R N) -> (xs :R List) -> (ys :R List) -> V (index n xs ys) {
    forall (xs :R List) (ys :R List).
    build Z xs ys ~> VNil
    
    forall (x :R B) (xs :R List) (y :R B) (ys :R List).
    build (S Z) (Cons x xs) (Cons y ys) ~> VOne x
    
    forall (n :R N) (x :R B) (xs :R List) (y :R B) (ys :R List).
    build (S (S n)) (Cons x xs) (Cons y ys) ~> VTwo x (index n xs ys) (build n xs ys) y
    
    forall (n :R N).
    build (S n) Nil Nil ~> VNil
  }

inferring  postulate eq :274 (xs :275 List) -> Id List (index (length xs) xs (reverse xs)) xs.

  inferred constraints: 
    I ~ 278
    L ~ 277
    R ~ 281
    R ~ 282
    R ~ 280
    R ~ 279
    L ~ 283
    L ~ 276
  
  
  variance of evars:
    covariant: []
    contravariant: [275]
  postulate eq :I (xs :I List) -> Id List (index (length xs) xs (reverse xs)) xs.

inferring  toV :668 (xs :669 List) -> V xs {
    forall (xs :671 List).
    toV xs ~> subst List V (index (length xs) xs (reverse xs)) xs (eq xs) (build (length xs) xs (reverse xs))
  }

  inferred constraints: 
    L ~ 670
    671 ~ product [669]
    669 ~ 672
    671 ≥ sum
      product [R, R, I]
      product [R, I]
      product [L, R, I]
      product [I]
      product [I, I]
      product [R, R, L]
      product [R, L]
      product [L, R, L]
    I ~ 678
    I ~ 677
    I ~ 676
    R ~ 681
    R ~ 682
    R ~ 680
    R ~ 679
    L ~ 683
    I ~ 675
    I ~ 674
    I ~ 684
    679 ~ R
    680 ~ R
    681 ~ R
    682 ~ R
    L ~ 673
    R ~ 687
    R ~ 688
    R ~ 686
    R ~ 685
    L ~ 689
    679 ~ R
    680 ~ R
    681 ~ R
    682 ~ 688
    L ~ 670
  
  
  variance of evars:
    covariant: []
    contravariant: [669]
  toV :I (xs :R List) -> V xs {
    forall (xs :R List).
    toV xs ~> subst List V (index (length xs) xs (reverse xs)) xs (eq xs) (build (length xs) xs (reverse xs))
  }

inferring  mutual {
    constructor/1 IsPalindrome :4 (_ :L List) -> Type.
    
    constructor/0 PNil :13 IsPalindrome Nil.
    
    constructor/1 POne :15 (b :L B) -> IsPalindrome (Cons b Nil).
    
    constructor/3 PTwo :19 (b :L B) -> (xs :I List) -> (pf :L IsPalindrome xs) -> IsPalindrome (Cons b (app xs (one b))).
  }

  inferred constraints: 
    L ~ 14
    L ~ 16
    L ~ 18
    L ~ 17
    L ~ 20
    L ~ 21
    L ~ 23
    L ~ 22
    L ~ 25
    L ~ 24
    L ~ 26
  
  
  variance of evars:
    covariant: []
    contravariant: []
  mutual {
    constructor/1 IsPalindrome :I (_ :L List) -> Type.
    
    constructor/0 PNil :I IsPalindrome Nil.
    
    constructor/1 POne :I (b :L B) -> IsPalindrome (Cons b Nil).
    
    constructor/3 PTwo :I (b :L B) -> (xs :I List) -> (pf :L IsPalindrome xs) -> IsPalindrome (Cons b (app xs (one b))).
  }

inferring  decEq :237 (x :238 B) -> (y :239 B) -> Maybe (Id B x y) {
    decEq T T ~> Just (Id B T T) (Refl B T)
    
    decEq F F ~> Just (Id B F F) (Refl B F)
    
    decEq T F ~> Nothing (Id B T F)
    
    decEq F T ~> Nothing (Id B F T)
  }

  inferred constraints: 
    L ~ 240
    I ~ 243
    L ~ 242
    L ~ 241
    238 ~ 244
    product [238] ≥ sum
      product [L]
    239 ~ 245
    product [239] ≥ sum
      product [L]
    I ~ 247
    I ~ 250
    L ~ 249
    L ~ 248
    L ~ 246
    I ~ 252
    I ~ 251
    248 ~ L
    249 ~ L
    250 ~ I
    L ~ 240
    238 ~ 253
    product [238] ≥ sum
      product [L]
    239 ~ 254
    product [239] ≥ sum
      product [L]
    I ~ 256
    I ~ 259
    L ~ 258
    L ~ 257
    L ~ 255
    I ~ 261
    I ~ 260
    257 ~ L
    258 ~ L
    259 ~ I
    L ~ 240
    238 ~ 262
    product [238] ≥ sum
      product [L]
    239 ~ 263
    product [239] ≥ sum
      product [L]
    I ~ 264
    I ~ 267
    L ~ 266
    L ~ 265
    L ~ 240
    238 ~ 268
    product [238] ≥ sum
      product [L]
    239 ~ 269
    product [239] ≥ sum
      product [L]
    I ~ 270
    I ~ 273
    L ~ 272
    L ~ 271
    L ~ 240
  
  deferred equalities: 
    240 -> Id B T T ~ Id B T T
    240 -> Id B F F ~ Id B F F
    240 -> Id B T F ~ Id B T F
    240 -> Id B F T ~ Id B F T
  
  variance of evars:
    covariant: []
    contravariant: [238, 239]
  -> iteration 1
    Id B T T ~ Id B T T
    Id B F F ~ Id B F F
    Id B T F ~ Id B T F
    Id B F T ~ Id B F T

  decEq :I (x :L B) -> (y :L B) -> Maybe (Id B x y) {
    decEq T T ~> Just (Id B T T) (Refl B T)
    
    decEq F F ~> Just (Id B F F) (Refl B F)
    
    decEq T F ~> Nothing (Id B T F)
    
    decEq F T ~> Nothing (Id B F T)
  }

inferring  isPalinV' :418 (x :419 B) -> (y :420 B) -> (xs :I List) -> (v :421 V xs) -> (pfB :423 Maybe (Id B x y)) -> (pfV :428 Maybe (IsPalindrome xs)) -> Maybe (IsPalindrome (Cons x (app xs (one y)))) {
    forall (x :443 B) (xs :442 List) (v :440 V xs) (pfV :438 IsPalindrome xs).
    isPalinV' x [x] xs v (Just [Id B x x] [Refl B x]) (Just [IsPalindrome xs] pfV) ~> Just (IsPalindrome (Cons x (app xs (one x)))) (PTwo x xs pfV)
    
    forall (x :483 B) (y :482 B) (xs :481 List) (v :479 V xs) (pfB :474 Maybe (Id B x y)) (pfV :471 Maybe (IsPalindrome xs)).
    isPalinV' x y xs v pfB pfV ~> Nothing (IsPalindrome (Cons x (app xs (one y))))
  }

  inferred constraints: 
    L ~ 422
    L ~ 424
    I ~ 427
    L ~ 426
    L ~ 425
    L ~ 429
    L ~ 430
    L ~ 431
    L ~ 432
    L ~ 434
    L ~ 433
    L ~ 436
    L ~ 435
    L ~ 437
    L ~ 441
    L ~ 439
    443 ~ product [419]
    442 ~ product [I]
    440 ~ product [421]
    438 ~ product [L, 428]
    419 ~ 444
    420 ~ 445
    I ~ 446
    421 ~ 447
    422 ~ 441
    423 ~ 448
    product [423] ≥ sum
      product [L]
    I ~ 449
    I ~ 452
    L ~ 451
    L ~ 450
    L ~ 453
    I ~ 455
    I ~ 454
    450 ~ L
    451 ~ L
    452 ~ I
    424 ~ L
    425 ~ 450
    426 ~ 451
    427 ~ 452
    428 ~ 456
    product [428] ≥ sum
      product [L]
    I ~ 457
    L ~ 458
    L ~ 459
    458 ~ 439
    429 ~ L
    430 ~ 458
    443 ≥ sum
      product [L, L, I]
      product [L, L, L, L, I]
      product [L, L]
    442 ≥ sum
      product [L, L, L, I]
      product [I, L]
    440 ≥ sum
    438 ≥ sum
      product [L, L]
    I ~ 461
    L ~ 462
    L ~ 464
    L ~ 463
    L ~ 466
    L ~ 465
    L ~ 467
    L ~ 460
    L ~ 470
    I ~ 469
    L ~ 468
    L ~ 439
    462 ~ L
    463 ~ L
    464 ~ L
    465 ~ L
    466 ~ L
    L ~ 431
    L ~ 480
    L ~ 475
    I ~ 478
    L ~ 477
    L ~ 476
    L ~ 472
    L ~ 473
    483 ~ product [419]
    482 ~ product [420]
    481 ~ product [I]
    479 ~ product [421]
    474 ~ product [423]
    471 ~ product [428]
    419 ~ 484
    420 ~ 485
    I ~ 486
    421 ~ 487
    422 ~ 480
    423 ~ 488
    424 ~ 475
    428 ~ 489
    429 ~ 472
    483 ≥ sum
      product [L, L, I]
    482 ≥ sum
      product [L, L, L, L, I]
    481 ≥ sum
      product [L, L, L, I]
    479 ≥ sum
    474 ≥ sum
    471 ≥ sum
    I ~ 490
    L ~ 491
    L ~ 493
    L ~ 492
    L ~ 495
    L ~ 494
    L ~ 496
    L ~ 431
  
  deferred equalities: 
    431 -> IsPalindrome (Cons x (app xs (one x))) ~ IsPalindrome (Cons x (app xs (one x)))
    475 -> Id B x y ~ Id B x y
    472 -> IsPalindrome xs ~ IsPalindrome xs
    431 -> IsPalindrome (Cons x (app xs (one y))) ~ IsPalindrome (Cons x (app xs (one y)))
  
  variance of evars:
    covariant: []
    contravariant: [419, 420, 421, 423, 428]
  -> iteration 1
    IsPalindrome (Cons x (app xs (one x))) ~ IsPalindrome (Cons x (app xs (one x)))
    Id B x y ~ Id B x y
    IsPalindrome xs ~ IsPalindrome xs
    IsPalindrome (Cons x (app xs (one y))) ~ IsPalindrome (Cons x (app xs (one y)))

  -> iteration 2
    Cons x (app xs (one x)) ~ Cons x (app xs (one x))
    Cons x (app xs (one y)) ~ Cons x (app xs (one y))

  -> iteration 3
    app xs (one x) ~ app xs (one x)
    app xs (one y) ~ app xs (one y)

  -> iteration 4
    one x ~ one x
    one y ~ one y

  isPalinV' :I (x :R B) -> (y :I B) -> (xs :I List) -> (v :I V xs) -> (pfB :R Maybe (Id B x y)) -> (pfV :R Maybe (IsPalindrome xs)) -> Maybe (IsPalindrome (Cons x (app xs (one y)))) {
    forall (x :R B) (xs :I List) (v :I V xs) (pfV :R IsPalindrome xs).
    isPalinV' x [x] xs v (Just [Id B x x] [Refl B x]) (Just [IsPalindrome xs] pfV) ~> Just (IsPalindrome (Cons x (app xs (one x)))) (PTwo x xs pfV)
    
    forall (x :R B) (y :I B) (xs :I List) (v :I V xs) (pfB :R Maybe (Id B x y)) (pfV :R Maybe (IsPalindrome xs)).
    isPalinV' x y xs v pfB pfV ~> Nothing (IsPalindrome (Cons x (app xs (one y))))
  }

inferring  isPalinV :369 (xs :370 List) -> (v :371 V xs) -> Maybe (IsPalindrome xs) {
    isPalinV [Nil] VNil ~> Just (IsPalindrome Nil) PNil
    
    forall (x :380 B).
    isPalinV [Cons x Nil] (VOne x) ~> Just (IsPalindrome (Cons x Nil)) (POne x)
    
    forall (x :396 B) (xs :395 List) (y :394 B) (v :392 V xs).
    isPalinV [Cons x (app xs (one y))] (VTwo x xs v y) ~> isPalinV' x y xs v (decEq x y) (isPalinV xs v)
  }

  inferred constraints: 
    L ~ 372
    L ~ 373
    L ~ 374
    370 ~ 375
    371 ~ 376
    product [371] ≥ sum
      product [L]
    372 ~ L
    I ~ 378
    L ~ 379
    L ~ 377
    379 ~ L
    L ~ 373
    380 ~ product [L, 371]
    370 ~ 381
    L ~ 383
    L ~ 382
    371 ~ 384
    product [371] ≥ sum
      product [L]
    L ~ 385
    372 ~ L
    382 ~ L
    383 ~ L
    380 ≥ sum
      product [L, L, I]
      product [L, L]
    I ~ 387
    L ~ 388
    L ~ 390
    L ~ 389
    L ~ 386
    L ~ 391
    388 ~ L
    389 ~ L
    390 ~ L
    L ~ 373
    L ~ 393
    396 ~ product [L, 371]
    395 ~ product [I, 371]
    394 ~ product [L, 371]
    392 ~ product [L, 371]
    370 ~ 397
    L ~ 399
    L ~ 398
    L ~ 401
    L ~ 400
    L ~ 402
    371 ~ 403
    product [371] ≥ sum
      product [L]
    L ~ 404
    I ~ 405
    L ~ 406
    L ~ 393
    L ~ 407
    372 ~ L
    398 ~ L
    399 ~ L
    400 ~ L
    401 ~ L
    396 ≥ sum
      product [R]
      product [L, R]
    395 ≥ sum
      product [I]
      product [370, R]
    394 ≥ sum
      product [I]
      product [L, R]
    392 ≥ sum
      product [I]
      product [371, R]
    R ~ 413
    I ~ 412
    I ~ 411
    I ~ 410
    L ~ 393
    R ~ 409
    L ~ 415
    L ~ 414
    R ~ 408
    370 ~ 417
    371 ~ 416
    372 ~ 393
    L ~ 373
    L ~ 373
  
  deferred equalities: 
    373 -> IsPalindrome Nil ~ IsPalindrome Nil
    373 -> IsPalindrome (Cons x Nil) ~ IsPalindrome (Cons x Nil)
    373 -> IsPalindrome xs ~ IsPalindrome xs
    373 -> IsPalindrome (Cons x (app xs (one y))) ~ IsPalindrome (Cons x (app xs (one y)))
  
  variance of evars:
    covariant: []
    contravariant: [370, 371]
  -> iteration 1
    IsPalindrome Nil ~ IsPalindrome Nil
    IsPalindrome (Cons x Nil) ~ IsPalindrome (Cons x Nil)
    IsPalindrome xs ~ IsPalindrome xs
    IsPalindrome (Cons x (app xs (one y))) ~ IsPalindrome (Cons x (app xs (one y)))

  -> iteration 2
    Cons x Nil ~ Cons x Nil
    Cons x (app xs (one y)) ~ Cons x (app xs (one y))

  -> iteration 3
    app xs (one y) ~ app xs (one y)

  -> iteration 4
    one y ~ one y

  isPalinV :I (xs :I List) -> (v :R V xs) -> Maybe (IsPalindrome xs) {
    isPalinV [Nil] VNil ~> Just (IsPalindrome Nil) PNil
    
    forall (x :R B).
    isPalinV [Cons x Nil] (VOne x) ~> Just (IsPalindrome (Cons x Nil)) (POne x)
    
    forall (x :R B) (xs :I List) (y :R B) (v :R V xs).
    isPalinV [Cons x (app xs (one y))] (VTwo x xs v y) ~> isPalinV' x y xs v (decEq x y) (isPalinV xs v)
  }

inferring  isPalindrome :497 (xs :498 List) -> Maybe (IsPalindrome xs) {
    forall (xs :501 List).
    isPalindrome xs ~> isPalinV xs (toV xs)
  }

  inferred constraints: 
    L ~ 499
    L ~ 500
    501 ~ product [498]
    498 ~ 502
    501 ≥ sum
      product [I]
      product [R, R]
    I ~ 504
    R ~ 503
    R ~ 505
    L ~ 499
  
  deferred equalities: 
    499 -> IsPalindrome xs ~ IsPalindrome xs
  
  variance of evars:
    covariant: []
    contravariant: [498]
  -> iteration 1
    IsPalindrome xs ~ IsPalindrome xs

  isPalindrome :I (xs :R List) -> Maybe (IsPalindrome xs) {
    forall (xs :R List).
    isPalindrome xs ~> isPalinV xs (toV xs)
  }

inferring  genList :284 (_ :285 B) -> (_ :286 N) -> List {
    forall (b :287 B).
    genList b Z ~> Nil
    
    forall (b :291 B) (n :290 N).
    genList b (S n) ~> Cons b (genList (not b) n)
  }

  inferred constraints: 
    287 ~ product [285]
    285 ~ 288
    286 ~ 289
    product [286] ≥ sum
      product [L]
    287 ≥ sum
    291 ~ product [285]
    290 ~ product [L, 286]
    285 ~ 292
    286 ~ 293
    product [286] ≥ sum
      product [L]
    L ~ 294
    291 ≥ sum
      product [L]
      product [L, 285, L]
    290 ≥ sum
      product [286, L]
    L ~ 296
    L ~ 295
    285 ~ 298
    L ~ 299
    286 ~ 297
  
  
  variance of evars:
    covariant: []
    contravariant: [285, 286]
  genList :I (_ :R B) -> (_ :L N) -> List {
    forall (b :R B).
    genList b Z ~> Nil
    
    forall (b :R B) (n :L N).
    genList b (S n) ~> Cons b (genList (not b) n)
  }

inferring  isJust :355 (a :356 Type) -> (x :357 Maybe a) -> B {
    forall (a :360 Type) (x :359 a).
    isJust a (Just [a] x) ~> T
    
    forall (a :365 Type).
    isJust a (Nothing [a]) ~> F
  }

  inferred constraints: 
    L ~ 358
    360 ~ product [356]
    359 ~ product [L, 357]
    356 ~ 361
    357 ~ 362
    product [357] ≥ sum
      product [L]
    I ~ 363
    L ~ 364
    358 ~ L
    360 ≥ sum
    359 ≥ sum
    365 ~ product [356]
    356 ~ 366
    357 ~ 367
    product [357] ≥ sum
      product [L]
    I ~ 368
    358 ~ L
    365 ≥ sum
  
  
  variance of evars:
    covariant: []
    contravariant: [356, 357]
  isJust :I (a :I Type) -> (x :R Maybe a) -> B {
    forall (a :I Type) (x :R a).
    isJust a (Just [a] x) ~> T
    
    forall (a :I Type).
    isJust a (Nothing [a]) ~> F
  }

inferring  testList :653 List {
    testList  ~> Cons T (Cons F (Cons F (Cons T (Cons F (Cons F (Cons T Nil))))))
  }

  inferred constraints: 
    L ~ 655
    L ~ 654
    L ~ 657
    L ~ 656
    L ~ 659
    L ~ 658
    L ~ 661
    L ~ 660
    L ~ 663
    L ~ 662
    L ~ 665
    L ~ 664
    L ~ 667
    L ~ 666
  
  
  variance of evars:
    covariant: []
    contravariant: []
  testList :I List {
    testList  ~> Cons T (Cons F (Cons F (Cons T (Cons F (Cons F (Cons T Nil))))))
  }

inferring  main :516 Maybe (IsPalindrome testList) {
    main  ~> isPalindrome testList
  }

  inferred constraints: 
    L ~ 517
    L ~ 518
    R ~ 519
    L ~ 517
  
  deferred equalities: 
    517 -> IsPalindrome testList ~ IsPalindrome testList
  
  variance of evars:
    covariant: []
    contravariant: []
  -> iteration 1
    IsPalindrome testList ~ IsPalindrome testList

  main :I Maybe (IsPalindrome testList) {
    main  ~> isPalindrome testList
  }


###################
# Final valuation #
###################

  0 -> I
  1 -> R
  2 -> R
  3 -> I
  4 -> I
  5 -> R
  6 -> L
  7 -> I
  8 -> I
  9 -> I
  10 -> R
  11 -> R
  12 -> L
  13 -> R
  14 -> L
  15 -> R
  16 -> L
  17 -> L
  18 -> L
  19 -> R
  20 -> L
  21 -> L
  22 -> L
  23 -> L
  24 -> L
  25 -> L
  26 -> L
  27 -> R
  28 -> L
  29 -> R
  30 -> L
  31 -> L
  32 -> L
  33 -> L
  34 -> L
  35 -> R
  36 -> L
  37 -> L
  38 -> I
  39 -> I
  40 -> R
  41 -> R
  42 -> I
  43 -> R
  44 -> L
  45 -> R
  46 -> L
  47 -> L
  48 -> L
  49 -> R
  50 -> L
  51 -> L
  52 -> L
  53 -> L
  54 -> L
  55 -> L
  56 -> L
  57 -> R
  58 -> I
  59 -> L
  60 -> L
  61 -> L
  62 -> L
  63 -> L
  64 -> L
  65 -> L
  66 -> L
  67 -> L
  68 -> L
  69 -> L
  70 -> L
  71 -> L
  72 -> L
  73 -> L
  74 -> L
  75 -> I
  76 -> R
  77 -> I
  78 -> I
  79 -> L
  80 -> L
  81 -> I
  82 -> L
  83 -> L
  84 -> L
  85 -> L
  86 -> L
  87 -> L
  88 -> L
  89 -> L
  90 -> I
  91 -> I
  92 -> R
  93 -> I
  94 -> I
  95 -> I
  96 -> I
  97 -> L
  98 -> L
  99 -> I
  100 -> I
  101 -> R
  102 -> R
  103 -> R
  104 -> L
  105 -> L
  106 -> I
  107 -> I
  108 -> I
  109 -> I
  110 -> I
  111 -> I
  112 -> I
  113 -> I
  114 -> L
  115 -> L
  116 -> L
  117 -> L
  118 -> L
  119 -> L
  120 -> L
  121 -> L
  122 -> L
  123 -> I
  124 -> I
  125 -> R
  126 -> I
  127 -> R
  128 -> L
  129 -> L
  130 -> I
  131 -> L
  132 -> L
  133 -> R
  134 -> I
  135 -> I
  136 -> R
  137 -> R
  138 -> R
  139 -> L
  140 -> L
  141 -> I
  142 -> I
  143 -> I
  144 -> I
  145 -> I
  146 -> I
  147 -> L
  148 -> L
  149 -> L
  150 -> R
  151 -> R
  152 -> R
  153 -> R
  154 -> R
  155 -> L
  156 -> R
  157 -> R
  158 -> R
  159 -> R
  160 -> R
  161 -> R
  162 -> R
  163 -> R
  164 -> R
  165 -> R
  166 -> R
  167 -> R
  168 -> R
  169 -> L
  170 -> R
  171 -> L
  172 -> L
  173 -> R
  174 -> L
  175 -> L
  176 -> L
  177 -> R
  178 -> R
  179 -> R
  180 -> R
  181 -> R
  182 -> R
  183 -> L
  184 -> L
  185 -> R
  186 -> L
  187 -> L
  188 -> R
  189 -> L
  190 -> L
  191 -> L
  192 -> L
  193 -> I
  194 -> L
  195 -> R
  196 -> R
  197 -> R
  198 -> R
  199 -> R
  200 -> R
  201 -> R
  202 -> R
  203 -> L
  204 -> R
  205 -> R
  206 -> I
  207 -> I
  208 -> I
  209 -> I
  210 -> I
  211 -> I
  212 -> I
  213 -> L
  214 -> L
  215 -> I
  216 -> L
  217 -> L
  218 -> I
  219 -> L
  220 -> L
  221 -> I
  222 -> I
  223 -> L
  224 -> I
  225 -> I
  226 -> I
  227 -> I
  228 -> I
  229 -> I
  230 -> I
  231 -> I
  232 -> I
  233 -> I
  234 -> I
  235 -> I
  236 -> L
  237 -> R
  238 -> L
  239 -> L
  240 -> L
  241 -> L
  242 -> L
  243 -> I
  244 -> L
  245 -> L
  246 -> L
  247 -> I
  248 -> L
  249 -> L
  250 -> I
  251 -> I
  252 -> I
  253 -> L
  254 -> L
  255 -> L
  256 -> I
  257 -> L
  258 -> L
  259 -> I
  260 -> I
  261 -> I
  262 -> L
  263 -> L
  264 -> I
  265 -> L
  266 -> L
  267 -> I
  268 -> L
  269 -> L
  270 -> I
  271 -> L
  272 -> L
  273 -> I
  274 -> I
  275 -> I
  276 -> L
  277 -> L
  278 -> I
  279 -> R
  280 -> R
  281 -> R
  282 -> R
  283 -> L
  284 -> I
  285 -> R
  286 -> L
  287 -> R
  288 -> R
  289 -> L
  290 -> L
  291 -> R
  292 -> R
  293 -> L
  294 -> L
  295 -> L
  296 -> L
  297 -> L
  298 -> R
  299 -> L
  300 -> I
  301 -> I
  302 -> L
  303 -> I
  304 -> L
  305 -> I
  306 -> R
  307 -> R
  308 -> R
  309 -> R
  310 -> R
  311 -> R
  312 -> R
  313 -> R
  314 -> R
  315 -> R
  316 -> R
  317 -> R
  318 -> R
  319 -> L
  320 -> R
  321 -> L
  322 -> L
  323 -> R
  324 -> L
  325 -> L
  326 -> L
  327 -> L
  328 -> R
  329 -> R
  330 -> R
  331 -> R
  332 -> R
  333 -> R
  334 -> L
  335 -> L
  336 -> R
  337 -> L
  338 -> L
  339 -> R
  340 -> L
  341 -> L
  342 -> L
  343 -> L
  344 -> L
  345 -> L
  346 -> R
  347 -> R
  348 -> R
  349 -> L
  350 -> R
  351 -> R
  352 -> L
  353 -> R
  354 -> R
  355 -> I
  356 -> I
  357 -> R
  358 -> L
  359 -> R
  360 -> I
  361 -> I
  362 -> R
  363 -> I
  364 -> L
  365 -> I
  366 -> I
  367 -> R
  368 -> I
  369 -> R
  370 -> I
  371 -> R
  372 -> L
  373 -> L
  374 -> L
  375 -> I
  376 -> R
  377 -> L
  378 -> I
  379 -> L
  380 -> R
  381 -> I
  382 -> L
  383 -> L
  384 -> R
  385 -> L
  386 -> L
  387 -> I
  388 -> L
  389 -> L
  390 -> L
  391 -> L
  392 -> R
  393 -> L
  394 -> R
  395 -> I
  396 -> R
  397 -> I
  398 -> L
  399 -> L
  400 -> L
  401 -> L
  402 -> L
  403 -> R
  404 -> L
  405 -> I
  406 -> L
  407 -> L
  408 -> R
  409 -> R
  410 -> I
  411 -> I
  412 -> I
  413 -> R
  414 -> L
  415 -> L
  416 -> R
  417 -> I
  418 -> R
  419 -> R
  420 -> I
  421 -> I
  422 -> L
  423 -> R
  424 -> L
  425 -> L
  426 -> L
  427 -> I
  428 -> R
  429 -> L
  430 -> L
  431 -> L
  432 -> L
  433 -> L
  434 -> L
  435 -> L
  436 -> L
  437 -> L
  438 -> R
  439 -> L
  440 -> I
  441 -> L
  442 -> I
  443 -> R
  444 -> R
  445 -> I
  446 -> I
  447 -> I
  448 -> R
  449 -> I
  450 -> L
  451 -> L
  452 -> I
  453 -> L
  454 -> I
  455 -> I
  456 -> R
  457 -> I
  458 -> L
  459 -> L
  460 -> L
  461 -> I
  462 -> L
  463 -> L
  464 -> L
  465 -> L
  466 -> L
  467 -> L
  468 -> L
  469 -> I
  470 -> L
  471 -> R
  472 -> L
  473 -> L
  474 -> R
  475 -> L
  476 -> L
  477 -> L
  478 -> I
  479 -> I
  480 -> L
  481 -> I
  482 -> I
  483 -> R
  484 -> R
  485 -> I
  486 -> I
  487 -> I
  488 -> R
  489 -> R
  490 -> I
  491 -> L
  492 -> L
  493 -> L
  494 -> L
  495 -> L
  496 -> L
  497 -> L
  498 -> R
  499 -> L
  500 -> L
  501 -> R
  502 -> R
  503 -> R
  504 -> I
  505 -> R
  506 -> R
  507 -> R
  508 -> R
  509 -> R
  510 -> R
  511 -> R
  512 -> L
  513 -> L
  514 -> L
  515 -> R
  516 -> L
  517 -> L
  518 -> L
  519 -> R
  520 -> I
  521 -> L
  522 -> L
  523 -> L
  524 -> I
  525 -> L
  526 -> L
  527 -> L
  528 -> L
  529 -> L
  530 -> R
  531 -> L
  532 -> L
  533 -> L
  534 -> L
  535 -> L
  536 -> L
  537 -> I
  538 -> R
  539 -> I
  540 -> L
  541 -> L
  542 -> L
  543 -> L
  544 -> L
  545 -> L
  546 -> L
  547 -> L
  548 -> I
  549 -> I
  550 -> L
  551 -> L
  552 -> L
  553 -> I
  554 -> I
  555 -> I
  556 -> I
  557 -> I
  558 -> L
  559 -> L
  560 -> R
  561 -> L
  562 -> L
  563 -> L
  564 -> L
  565 -> I
  566 -> I
  567 -> L
  568 -> L
  569 -> L
  570 -> L
  571 -> L
  572 -> I
  573 -> I
  574 -> I
  575 -> I
  576 -> I
  577 -> L
  578 -> L
  579 -> L
  580 -> L
  581 -> L
  582 -> L
  583 -> L
  584 -> L
  585 -> L
  586 -> I
  587 -> I
  588 -> R
  589 -> L
  590 -> L
  591 -> L
  592 -> I
  593 -> L
  594 -> L
  595 -> L
  596 -> L
  597 -> L
  598 -> I
  599 -> R
  600 -> L
  601 -> L
  602 -> L
  603 -> L
  604 -> I
  605 -> L
  606 -> R
  607 -> I
  608 -> L
  609 -> L
  610 -> I
  611 -> L
  612 -> L
  613 -> L
  614 -> L
  615 -> I
  616 -> I
  617 -> L
  618 -> L
  619 -> L
  620 -> L
  621 -> I
  622 -> L
  623 -> L
  624 -> L
  625 -> L
  626 -> L
  627 -> I
  628 -> R
  629 -> I
  630 -> I
  631 -> I
  632 -> I
  633 -> I
  634 -> L
  635 -> L
  636 -> I
  637 -> L
  638 -> L
  639 -> L
  640 -> I
  641 -> I
  642 -> L
  643 -> I
  644 -> I
  645 -> I
  646 -> I
  647 -> I
  648 -> I
  649 -> I
  650 -> I
  651 -> L
  652 -> L
  653 -> R
  654 -> L
  655 -> L
  656 -> L
  657 -> L
  658 -> L
  659 -> L
  660 -> L
  661 -> L
  662 -> L
  663 -> L
  664 -> L
  665 -> L
  666 -> L
  667 -> L
  668 -> R
  669 -> R
  670 -> L
  671 -> R
  672 -> R
  673 -> L
  674 -> I
  675 -> I
  676 -> I
  677 -> I
  678 -> I
  679 -> R
  680 -> R
  681 -> R
  682 -> R
  683 -> L
  684 -> I
  685 -> R
  686 -> R
  687 -> R
  688 -> R
  689 -> L


#####################
# Annotated program #
#####################

mutual {
  constructor/0 N :I Type.
  
  constructor/0 Z :R N.
  
  constructor/1 S :R (_ :L N) -> N.
}

mutual {
  constructor/0 B :I Type.
  
  constructor/0 T :R B.
  
  constructor/0 F :R B.
}

mutual {
  constructor/0 List :I Type.
  
  constructor/2 Cons :R (_ :L B) -> (_ :L List) -> List.
  
  constructor/0 Nil :R List.
}

mutual {
  constructor/1 Maybe :I (_ :L Type) -> Type.
  
  constructor/1 Nothing :R (a :I Type) -> Maybe a.
  
  constructor/2 Just :R (a :I Type) -> (_ :L a) -> Maybe a.
}

not :I (_ :L B) -> B {
  not T ~> F
  
  not F ~> T
}

mutual {
  constructor/3 Id :I (a :I Type) -> (_ :L a) -> (_ :L a) -> Type.
  
  constructor/2 Refl :R (a :I Type) -> (x :I a) -> Id a x x.
}

id :I (a :I Type) -> (_ :L a) -> a {
  id  ~> \a :I Type.
      \x :L a.
        x
}

subst :R (a :I Type) -> (P :I (x :L a) -> Type) -> (x :I a) -> (y :I a) -> (_ :I Id a x y) -> (_ :L P x) -> P y {
  forall (a :I Type) (P :I (_ :L a) -> Type) (x :I a).
  subst a P x [x] ({Refl} [a] [x]) ~> \w :L P x.
      w
}

cong :I (a :I Type) -> (b :I Type) -> (f :I (x :L a) -> b) -> (x :I a) -> (y :I a) -> (_ :I Id a x y) -> Id b (f x) (f y) {
  forall (a :I Type) (b :I Type) (f :I (_ :L a) -> b) (x :I a).
  cong a b f x [x] [Refl a x] ~> Refl b (f x)
}

one :I (x :L B) -> List {
  forall (x :L B).
  one x ~> Cons x Nil
}

app :I (_ :L List) -> (_ :L List) -> List {
  forall (ys :L List).
  app Nil ys ~> ys
  
  forall (x :L B) (xs :L List) (ys :L List).
  app (Cons x xs) ys ~> Cons x (app xs ys)
}

appRightNeutral :I (ys :R List) -> Id List ys (app ys Nil) {
  appRightNeutral Nil ~> Refl List Nil
  
  forall (x :R B) (xs :R List).
  appRightNeutral (Cons x xs) ~> cong List List (Cons x) xs (app xs Nil) (appRightNeutral xs)
}

appAssoc :I (xs :R List) -> (ys :I List) -> (zs :I List) -> Id List (app (app xs ys) zs) (app xs (app ys zs)) {
  forall (ys :I List) (zs :I List).
  appAssoc Nil ys zs ~> Refl List (app ys zs)
  
  forall (x :R B) (xs :R List) (ys :I List) (zs :I List).
  appAssoc (Cons x xs) ys zs ~> cong List List (Cons x) (app (app xs ys) zs) (app xs (app ys zs)) (appAssoc xs ys zs)
}

mutual {
  constructor/1 Rev :I (_ :L List) -> Type.
  
  constructor/0 RNil :R Rev Nil.
  
  constructor/3 RSnoc :R (xs :I List) -> (x :L B) -> (rxs :L Rev xs) -> Rev (app xs (one x)).
}

rev' :R (xs :I List) -> (rxs :L Rev xs) -> (ys :L List) -> Rev (app xs ys) {
  forall (xs :I List) (rxs :L Rev xs).
  rev' xs rxs Nil ~> subst List Rev xs (app xs Nil) (appRightNeutral xs) rxs
  
  forall (xs :I List) (rxs :L Rev xs) (y :L B) (ys :L List).
  rev' xs rxs (Cons y ys) ~> subst List Rev (app (app xs (one y)) ys) (app xs (Cons y ys)) (appAssoc xs (one y) ys) (rev' (app xs (one y)) (RSnoc xs y rxs) ys)
}

rev :R (xs :L List) -> Rev xs {
  forall (xs :L List).
  rev xs ~> rev' Nil RNil xs
}

reverse' :R (xs :I List) -> (rxs :L Rev xs) -> List {
  reverse' [Nil] RNil ~> Nil
  
  forall (xs :I List) (x :L B) (rxs :L Rev xs).
  reverse' [app xs (one x)] (RSnoc xs x rxs) ~> Cons x (reverse' xs rxs)
}

reverse :R (_ :L List) -> List {
  forall (xs :L List).
  reverse xs ~> reverse' xs (rev xs)
}

mutual {
  constructor/1 V :I (_ :L List) -> Type.
  
  constructor/0 VNil :R V Nil.
  
  constructor/1 VOne :R (x :L B) -> V (Cons x Nil).
  
  constructor/4 VTwo :R (x :L B) -> (xs :I List) -> (u :L V xs) -> (y :L B) -> V (Cons x (app xs (one y))).
}

length :R (_ :R List) -> N {
  length Nil ~> Z
  
  forall (x :R B) (xs :R List).
  length (Cons x xs) ~> S (length xs)
}

index :I (_ :R N) -> (_ :R List) -> (_ :R List) -> List {
  forall (xs :R List) (ys :R List).
  index Z xs ys ~> Nil
  
  forall (x :R B) (xs :R List) (y :R B) (ys :R List).
  index (S Z) (Cons x xs) (Cons y ys) ~> Cons x Nil
  
  forall (n :R N) (x :R B) (xs :R List) (y :R B) (ys :R List).
  index (S (S n)) (Cons x xs) (Cons y ys) ~> Cons x (app (index n xs ys) (one y))
  
  forall (n :R N).
  index (S n) Nil Nil ~> Nil
}

build :R (n :R N) -> (xs :R List) -> (ys :R List) -> V (index n xs ys) {
  forall (xs :R List) (ys :R List).
  build Z xs ys ~> VNil
  
  forall (x :R B) (xs :R List) (y :R B) (ys :R List).
  build (S Z) (Cons x xs) (Cons y ys) ~> VOne x
  
  forall (n :R N) (x :R B) (xs :R List) (y :R B) (ys :R List).
  build (S (S n)) (Cons x xs) (Cons y ys) ~> VTwo x (index n xs ys) (build n xs ys) y
  
  forall (n :R N).
  build (S n) Nil Nil ~> VNil
}

postulate eq :I (xs :I List) -> Id List (index (length xs) xs (reverse xs)) xs.

toV :R (xs :R List) -> V xs {
  forall (xs :R List).
  toV xs ~> subst List V (index (length xs) xs (reverse xs)) xs (eq xs) (build (length xs) xs (reverse xs))
}

mutual {
  constructor/1 IsPalindrome :I (_ :L List) -> Type.
  
  constructor/0 PNil :R IsPalindrome Nil.
  
  constructor/1 POne :R (b :L B) -> IsPalindrome (Cons b Nil).
  
  constructor/3 PTwo :R (b :L B) -> (xs :I List) -> (pf :L IsPalindrome xs) -> IsPalindrome (Cons b (app xs (one b))).
}

decEq :R (x :L B) -> (y :L B) -> Maybe (Id B x y) {
  decEq T T ~> Just (Id B T T) (Refl B T)
  
  decEq F F ~> Just (Id B F F) (Refl B F)
  
  decEq T F ~> Nothing (Id B T F)
  
  decEq F T ~> Nothing (Id B F T)
}

isPalinV' :R (x :R B) -> (y :I B) -> (xs :I List) -> (v :I V xs) -> (pfB :R Maybe (Id B x y)) -> (pfV :R Maybe (IsPalindrome xs)) -> Maybe (IsPalindrome (Cons x (app xs (one y)))) {
  forall (x :R B) (xs :I List) (v :I V xs) (pfV :R IsPalindrome xs).
  isPalinV' x [x] xs v (Just [Id B x x] [Refl B x]) (Just [IsPalindrome xs] pfV) ~> Just (IsPalindrome (Cons x (app xs (one x)))) (PTwo x xs pfV)
  
  forall (x :R B) (y :I B) (xs :I List) (v :I V xs) (pfB :R Maybe (Id B x y)) (pfV :R Maybe (IsPalindrome xs)).
  isPalinV' x y xs v pfB pfV ~> Nothing (IsPalindrome (Cons x (app xs (one y))))
}

isPalinV :R (xs :I List) -> (v :R V xs) -> Maybe (IsPalindrome xs) {
  isPalinV [Nil] VNil ~> Just (IsPalindrome Nil) PNil
  
  forall (x :R B).
  isPalinV [Cons x Nil] (VOne x) ~> Just (IsPalindrome (Cons x Nil)) (POne x)
  
  forall (x :R B) (xs :I List) (y :R B) (v :R V xs).
  isPalinV [Cons x (app xs (one y))] (VTwo x xs v y) ~> isPalinV' x y xs v (decEq x y) (isPalinV xs v)
}

isPalindrome :L (xs :R List) -> Maybe (IsPalindrome xs) {
  forall (xs :R List).
  isPalindrome xs ~> isPalinV xs (toV xs)
}

genList :I (_ :R B) -> (_ :L N) -> List {
  forall (b :R B).
  genList b Z ~> Nil
  
  forall (b :R B) (n :L N).
  genList b (S n) ~> Cons b (genList (not b) n)
}

isJust :I (a :I Type) -> (x :R Maybe a) -> B {
  forall (a :I Type) (x :R a).
  isJust a (Just [a] x) ~> T
  
  forall (a :I Type).
  isJust a (Nothing [a]) ~> F
}

testList :R List {
  testList  ~> Cons T (Cons F (Cons F (Cons T (Cons F (Cons F (Cons T Nil))))))
}

main :L Maybe (IsPalindrome testList) {
  main  ~> isPalindrome testList
}


##########
# Pruned #
##########

mutual {
  constructor/0 N :I Type.
  
  constructor/0 Z :R N.
  
  constructor/1 S :R (_ :L N) -> N.
}

mutual {
  constructor/0 B :I Type.
  
  constructor/0 T :R B.
  
  constructor/0 F :R B.
}

mutual {
  constructor/0 List :I Type.
  
  constructor/2 Cons :R (_ :L B) -> (_ :L List) -> List.
  
  constructor/0 Nil :R List.
}

mutual {
  constructor/1 Maybe :I (_ :L Type) -> Type.
  
  constructor/1 Nothing :R (a :I Type) -> Maybe a.
  
  constructor/2 Just :R (a :I Type) -> (_ :L a) -> Maybe a.
}

not :I (_ :L B) -> B {
  not T ~> F
  
  not F ~> T
}

mutual {
  constructor/3 Id :I (a :I Type) -> (_ :L a) -> (_ :L a) -> Type.
  
  constructor/2 Refl :R (a :I Type) -> (x :I a) -> Id a x x.
}

id :I (a :I Type) -> (_ :L a) -> a {
  id  ~> \a :I Type.
      \x :L a.
        x
}

subst :R (a :I Type) -> (P :I (x :L a) -> Type) -> (x :I a) -> (y :I a) -> (_ :I Id a x y) -> (_ :L P x) -> P y {
  forall (a :I Type) (P :I (_ :L a) -> Type) (x :I a).
  subst a P x [x] ({Refl} [a] [x]) ~> \w :L P x.
      w
}

cong :I (a :I Type) -> (b :I Type) -> (f :I (x :L a) -> b) -> (x :I a) -> (y :I a) -> (_ :I Id a x y) -> Id b (f x) (f y) {
  forall (a :I Type) (b :I Type) (f :I (_ :L a) -> b) (x :I a).
  cong a b f x [x] [Refl a x] ~> Refl b (f x)
}

one :I (x :L B) -> List {
  forall (x :L B).
  one x ~> Cons x Nil
}

app :I (_ :L List) -> (_ :L List) -> List {
  forall (ys :L List).
  app Nil ys ~> ys
  
  forall (x :L B) (xs :L List) (ys :L List).
  app (Cons x xs) ys ~> Cons x (app xs ys)
}

appRightNeutral :I (ys :R List) -> Id List ys (app ys Nil) {
  appRightNeutral Nil ~> Refl List Nil
  
  forall (x :R B) (xs :R List).
  appRightNeutral (Cons x xs) ~> cong List List (Cons x) xs (app xs Nil) (appRightNeutral xs)
}

appAssoc :I (xs :R List) -> (ys :I List) -> (zs :I List) -> Id List (app (app xs ys) zs) (app xs (app ys zs)) {
  forall (ys :I List) (zs :I List).
  appAssoc Nil ys zs ~> Refl List (app ys zs)
  
  forall (x :R B) (xs :R List) (ys :I List) (zs :I List).
  appAssoc (Cons x xs) ys zs ~> cong List List (Cons x) (app (app xs ys) zs) (app xs (app ys zs)) (appAssoc xs ys zs)
}

mutual {
  constructor/1 Rev :I (_ :L List) -> Type.
  
  constructor/0 RNil :R Rev Nil.
  
  constructor/3 RSnoc :R (xs :I List) -> (x :L B) -> (rxs :L Rev xs) -> Rev (app xs (one x)).
}

rev' :R (xs :I List) -> (rxs :L Rev xs) -> (ys :L List) -> Rev (app xs ys) {
  forall (xs :I List) (rxs :L Rev xs).
  rev' xs rxs Nil ~> subst List Rev xs (app xs Nil) (appRightNeutral xs) rxs
  
  forall (xs :I List) (rxs :L Rev xs) (y :L B) (ys :L List).
  rev' xs rxs (Cons y ys) ~> subst List Rev (app (app xs (one y)) ys) (app xs (Cons y ys)) (appAssoc xs (one y) ys) (rev' (app xs (one y)) (RSnoc xs y rxs) ys)
}

rev :R (xs :L List) -> Rev xs {
  forall (xs :L List).
  rev xs ~> rev' Nil RNil xs
}

reverse' :R (xs :I List) -> (rxs :L Rev xs) -> List {
  reverse' [Nil] RNil ~> Nil
  
  forall (xs :I List) (x :L B) (rxs :L Rev xs).
  reverse' [app xs (one x)] (RSnoc xs x rxs) ~> Cons x (reverse' xs rxs)
}

reverse :R (_ :L List) -> List {
  forall (xs :L List).
  reverse xs ~> reverse' xs (rev xs)
}

mutual {
  constructor/1 V :I (_ :L List) -> Type.
  
  constructor/0 VNil :R V Nil.
  
  constructor/1 VOne :R (x :L B) -> V (Cons x Nil).
  
  constructor/4 VTwo :R (x :L B) -> (xs :I List) -> (u :L V xs) -> (y :L B) -> V (Cons x (app xs (one y))).
}

length :R (_ :R List) -> N {
  length Nil ~> Z
  
  forall (x :R B) (xs :R List).
  length (Cons x xs) ~> S (length xs)
}

index :I (_ :R N) -> (_ :R List) -> (_ :R List) -> List {
  forall (xs :R List) (ys :R List).
  index Z xs ys ~> Nil
  
  forall (x :R B) (xs :R List) (y :R B) (ys :R List).
  index (S Z) (Cons x xs) (Cons y ys) ~> Cons x Nil
  
  forall (n :R N) (x :R B) (xs :R List) (y :R B) (ys :R List).
  index (S (S n)) (Cons x xs) (Cons y ys) ~> Cons x (app (index n xs ys) (one y))
  
  forall (n :R N).
  index (S n) Nil Nil ~> Nil
}

build :R (n :R N) -> (xs :R List) -> (ys :R List) -> V (index n xs ys) {
  forall (xs :R List) (ys :R List).
  build Z xs ys ~> VNil
  
  forall (x :R B) (xs :R List) (y :R B) (ys :R List).
  build (S Z) (Cons x xs) (Cons y ys) ~> VOne x
  
  forall (n :R N) (x :R B) (xs :R List) (y :R B) (ys :R List).
  build (S (S n)) (Cons x xs) (Cons y ys) ~> VTwo x (index n xs ys) (build n xs ys) y
  
  forall (n :R N).
  build (S n) Nil Nil ~> VNil
}

postulate eq :I (xs :I List) -> Id List (index (length xs) xs (reverse xs)) xs.

toV :R (xs :R List) -> V xs {
  forall (xs :R List).
  toV xs ~> subst List V (index (length xs) xs (reverse xs)) xs (eq xs) (build (length xs) xs (reverse xs))
}

mutual {
  constructor/1 IsPalindrome :I (_ :L List) -> Type.
  
  constructor/0 PNil :R IsPalindrome Nil.
  
  constructor/1 POne :R (b :L B) -> IsPalindrome (Cons b Nil).
  
  constructor/3 PTwo :R (b :L B) -> (xs :I List) -> (pf :L IsPalindrome xs) -> IsPalindrome (Cons b (app xs (one b))).
}

decEq :R (x :L B) -> (y :L B) -> Maybe (Id B x y) {
  decEq T T ~> Just (Id B T T) (Refl B T)
  
  decEq F F ~> Just (Id B F F) (Refl B F)
  
  decEq T F ~> Nothing (Id B T F)
  
  decEq F T ~> Nothing (Id B F T)
}

isPalinV' :R (x :R B) -> (y :I B) -> (xs :I List) -> (v :I V xs) -> (pfB :R Maybe (Id B x y)) -> (pfV :R Maybe (IsPalindrome xs)) -> Maybe (IsPalindrome (Cons x (app xs (one y)))) {
  forall (x :R B) (xs :I List) (v :I V xs) (pfV :R IsPalindrome xs).
  isPalinV' x [x] xs v (Just [Id B x x] [Refl B x]) (Just [IsPalindrome xs] pfV) ~> Just (IsPalindrome (Cons x (app xs (one x)))) (PTwo x xs pfV)
  
  forall (x :R B) (y :I B) (xs :I List) (v :I V xs) (pfB :R Maybe (Id B x y)) (pfV :R Maybe (IsPalindrome xs)).
  isPalinV' x y xs v pfB pfV ~> Nothing (IsPalindrome (Cons x (app xs (one y))))
}

isPalinV :R (xs :I List) -> (v :R V xs) -> Maybe (IsPalindrome xs) {
  isPalinV [Nil] VNil ~> Just (IsPalindrome Nil) PNil
  
  forall (x :R B).
  isPalinV [Cons x Nil] (VOne x) ~> Just (IsPalindrome (Cons x Nil)) (POne x)
  
  forall (x :R B) (xs :I List) (y :R B) (v :R V xs).
  isPalinV [Cons x (app xs (one y))] (VTwo x xs v y) ~> isPalinV' x y xs v (decEq x y) (isPalinV xs v)
}

isPalindrome :L (xs :R List) -> Maybe (IsPalindrome xs) {
  forall (xs :R List).
  isPalindrome xs ~> isPalinV xs (toV xs)
}

genList :I (_ :R B) -> (_ :L N) -> List {
  forall (b :R B).
  genList b Z ~> Nil
  
  forall (b :R B) (n :L N).
  genList b (S n) ~> Cons b (genList (not b) n)
}

isJust :I (a :I Type) -> (x :R Maybe a) -> B {
  forall (a :I Type) (x :R a).
  isJust a (Just [a] x) ~> T
  
  forall (a :I Type).
  isJust a (Nothing [a]) ~> F
}

testList :R List {
  testList  ~> Cons T (Cons F (Cons F (Cons T (Cons F (Cons F (Cons T Nil))))))
}

main :L Maybe (IsPalindrome testList) {
  main  ~> isPalindrome testList
}

##########
# Erased #
##########

mutual {
  constructor/0 Z.
  
  constructor/1 S.
}

mutual {
  constructor/0 T.
  
  constructor/0 F.
}

mutual {
  constructor/2 Cons.
  
  constructor/0 Nil.
}

mutual {
  constructor/0 Nothing.
  
  constructor/1 Just.
}

constructor/0 Refl.

subst {
  subst  ~> \w.
      w
}

mutual {
  constructor/0 RNil.
  
  constructor/2 RSnoc.
}

rev' {
  forall (rxs).
  rev' rxs Nil ~> subst rxs
  
  forall (rxs) (y) (ys).
  rev' rxs (Cons y ys) ~> subst (rev' (RSnoc y rxs) ys)
}

rev {
  forall (xs).
  rev xs ~> rev' RNil xs
}

reverse' {
  reverse' RNil ~> Nil
  
  forall (x) (rxs).
  reverse' (RSnoc x rxs) ~> Cons x (reverse' rxs)
}

reverse {
  forall (xs).
  reverse xs ~> reverse' (rev xs)
}

mutual {
  constructor/0 VNil.
  
  constructor/1 VOne.
  
  constructor/3 VTwo.
}

length {
  length Nil ~> Z
  
  forall (x) (xs).
  length (Cons x xs) ~> S (length xs)
}

build {
  forall (xs) (ys).
  build Z xs ys ~> VNil
  
  forall (x) (xs) (y) (ys).
  build (S Z) (Cons x xs) (Cons y ys) ~> VOne x
  
  forall (n) (x) (xs) (y) (ys).
  build (S (S n)) (Cons x xs) (Cons y ys) ~> VTwo x (build n xs ys) y
  
  forall (n).
  build (S n) Nil Nil ~> VNil
}

toV {
  forall (xs).
  toV xs ~> subst (build (length xs) xs (reverse xs))
}

mutual {
  constructor/0 PNil.
  
  constructor/1 POne.
  
  constructor/2 PTwo.
}

decEq {
  decEq T T ~> Just Refl
  
  decEq F F ~> Just Refl
  
  decEq T F ~> Nothing
  
  decEq F T ~> Nothing
}

isPalinV' {
  forall (x) (pfV).
  isPalinV' x (Just [Refl]) (Just pfV) ~> Just (PTwo x pfV)
  
  forall (x) (pfB) (pfV).
  isPalinV' x pfB pfV ~> Nothing
}

isPalinV {
  isPalinV VNil ~> Just PNil
  
  forall (x).
  isPalinV (VOne x) ~> Just (POne x)
  
  forall (x) (y) (v).
  isPalinV (VTwo x v y) ~> isPalinV' x (decEq x y) (isPalinV v)
}

isPalindrome {
  forall (xs).
  isPalindrome xs ~> isPalinV (toV xs)
}

testList {
  testList  ~> Cons T (Cons F (Cons F (Cons T (Cons F (Cons F (Cons T Nil))))))
}

main {
  main  ~> isPalindrome testList
}

################
# NF of `main` #
################

Unerased, reduced:
isPalinV (Cons T (Cons F (Cons F (Cons T (Cons F (Cons F (Cons T Nil))))))) (subst List V (Cons T (Cons F (Cons F (Cons T (Cons F (Cons F (Cons T Nil))))))) (Cons T (Cons F (Cons F (Cons T (Cons F (Cons F (Cons T Nil))))))) (eq (Cons T (Cons F (Cons F (Cons T (Cons F (Cons F (Cons T Nil)))))))) (VTwo T (Cons F (Cons F (Cons T (Cons F (Cons F Nil))))) (VTwo F (Cons F (Cons T (Cons F Nil))) (VTwo F (Cons T Nil) (VOne T) F) F) T))

Erased, reduced:
Just (PTwo T (PTwo F (PTwo F (POne T))))
