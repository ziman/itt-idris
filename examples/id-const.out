#############
# Desugared #
#############

constructor Bool : Type.

constructor True : Bool.

constructor False : Bool.

constructor Pair : Type.

constructor P : (x :L Bool) -> (y :L Bool) -> Pair.

not : (x : Bool) -> Bool {
  not True ~> False
  not False ~> True
}

false : (x : Bool) -> Bool {
  forall (x : Bool).
    false x ~> False
}

true : (x : Bool) -> Bool {
  forall (x : Bool).
    true x ~> True
}

apply : (f : (x : Bool) -> Bool) -> (y : Bool) -> Bool {
  forall (y : Bool)(f : (x : Bool) -> Bool).
    apply f y ~> f y
}

main :L Pair {
  main ~> P (apply not (true False)) (apply false (true False))
}

#############
# Evarified #
#############

constructor Bool :0 Type.

constructor True :4 Bool.

constructor False :1 Bool.

constructor Pair :3 Type.

constructor P :2 (x :L Bool) -> (y :L Bool) -> Pair.

not :27 (x :28 Bool) -> Bool {
  not True ~> False
  not False ~> True
}

false :15 (x :16 Bool) -> Bool {
  forall (x :17 Bool).
    false x ~> False
}

true :31 (x :32 Bool) -> Bool {
  forall (x :33 Bool).
    true x ~> True
}

apply :5 (f :6 (x :7 Bool) -> Bool) -> (y :8 Bool) -> Bool {
  forall (y :9 Bool)(f :10 (x :11 Bool) -> Bool).
    apply f y ~> f y
}

main :L Pair {
  main ~> P (apply not (true False)) (apply false (true False))
}

Running erasure inference...
########################
# Inferred constraints #
########################

Sums:
  L ≥ Sum
    product  [I]
    product  [I]
  0 ≥ Sum
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
  1 ≥ Sum
    product  []
    product  []
    product  [20, 21, 23]
    product  [19, 24, 26]
  2 ≥ Sum
    product  []
  3 ≥ Sum
    product  [I]
    product  [I]
  4 ≥ Sum
    product  []
    product  []
  5 ≥ Sum
    product  [20]
    product  [19]
  6 ≥ Sum
    product  [I]
  7 ≥ Sum
    product  [I]
  8 ≥ Sum
    product  [I]
  9 ≥ Sum
    product  [I]
    product  [14]
  10 ≥ Sum
    product  [I]
    product  [I]
    product  []
  11 ≥ Sum
    product  [I]
    product  [I]
  12 ≥ Sum
    product  [10]
  13 ≥ Sum
    product  [9]
  15 ≥ Sum
    product  [19, 25]
  16 ≥ Sum
    product  [I]
    product  [I]
  17 ≥ Sum
    product  [I]
  18 ≥ Sum
    product  [17]
  27 ≥ Sum
    product  [20, 22]
  28 ≥ Sum
    product  [I]
    product  [I]
  31 ≥ Sum
    product  [20, 21]
    product  [19, 24]
  32 ≥ Sum
    product  [I]
  33 ≥ Sum
    product  [I]
  34 ≥ Sum
    product  [33]

Maxes:
  L ≥ Max
    product  [20]
    product  [19]
  1 ≥ Max
    product  [L, 27]
  4 ≥ Max
    product  [L, 27]
  6 ≥ Max
    product  [12]
    product  [22]
    product  [25]
  7 ≥ Max
    product  [11]
    product  [28]
    product  [16]
  8 ≥ Max
    product  [13]
    product  [21]
    product  [24]
  11 ≥ Max
    product  [7]
    product  [14]
  12 ≥ Max
    product  [6]
  13 ≥ Max
    product  [8]
  14 ≥ Max
    product  [11]
  16 ≥ Max
    product  [18]
    product  [7]
  18 ≥ Max
    product  [16]
  19 ≥ Max
    product  [L]
  20 ≥ Max
    product  [L]
  21 ≥ Max
    product  [8]
  22 ≥ Max
    product  [6]
  23 ≥ Max
    product  [32]
  24 ≥ Max
    product  [8]
  25 ≥ Max
    product  [6]
  26 ≥ Max
    product  [32]
  28 ≥ Max
    product  [29]
    product  [30]
    product  [7]
  29 ≥ Max
    product  [L]
    product  [28]
  30 ≥ Max
    product  [L]
    product  [28]
  32 ≥ Max
    product  [34]
    product  [23]
    product  [26]
  34 ≥ Max
    product  [32]

#######################
# Deferred equalities #
#######################


  -> iteration 1
    -> No more equalities, fixed point reached.

###################
# Final valuation #
###################

  0 -> I
  1 -> R
  2 -> L
  3 -> I
  4 -> R
  5 -> R
  6 -> L
  7 -> L
  8 -> L
  9 -> L
  10 -> L
  11 -> L
  12 -> L
  13 -> L
  14 -> L
  15 -> L
  16 -> L
  17 -> I
  18 -> L
  19 -> L
  20 -> L
  21 -> L
  22 -> L
  23 -> I
  24 -> L
  25 -> L
  26 -> I
  27 -> L
  28 -> L
  29 -> L
  30 -> L
  31 -> R
  32 -> I
  33 -> I
  34 -> I

#####################
# Annotated program #
#####################

constructor Bool :I Type.

constructor True :R Bool.

constructor False :R Bool.

constructor Pair :I Type.

constructor P :L (x :L Bool) -> (y :L Bool) -> Pair.

not :L (x :L Bool) -> Bool {
  not True ~> False
  not False ~> True
}

false :L (x :L Bool) -> Bool {
  forall (x :I Bool).
    false x ~> False
}

true :R (x :I Bool) -> Bool {
  forall (x :I Bool).
    true x ~> True
}

apply :R (f :L (x :L Bool) -> Bool) -> (y :L Bool) -> Bool {
  forall (y :L Bool)(f :L (x :L Bool) -> Bool).
    apply f y ~> f y
}

main :L Pair {
  main ~> P (apply not (true False)) (apply false (true False))
}

###############
# Final check #
###############

** OK **

##########
# Erased #
##########

constructor True : Bool.

constructor False : Bool.

constructor P : (x) -> (y) -> Pair.

not : (x) -> Bool {
  not True ~> False
  not False ~> True
}

false : (x) -> Bool {
  false _ ~> False
}

true : Bool {
  true ~> True
}

apply : (f) -> (y) -> Bool {
  forall (y)(f).
    apply f y ~> f y
}

main : Pair {
  main ~> P (apply not true) (apply false true)
}

################
# NF of `main` #
################

Unerased, reduced:
P False False

Erased, reduced:
P False False
