#############
# Desugared #
#############

constructor Bool : Type.

constructor True : Bool.

constructor False : Bool.

constructor Nat : Type.

constructor Z : Nat.

constructor S : (n :L Nat) -> Nat.

constructor Vect : (n :E Nat) -> Type.

constructor Nil : Vect Z.

constructor Cons : (n :I Nat) -> (x :L Bool) -> (xs :L Vect n) -> Vect (S n).

length : (n : Nat) -> (xs : Vect n) -> Nat {
  length {Z} Nil ~> Z
  forall (xs : Vect n) (x : Bool) (n : Nat).
    length ({S} n) (Cons [n] x xs) ~> S (length n xs)
}

main :L Nat {
  main ~> length (S Z) (Cons Z True Nil)
}

#############
# Evarified #
#############

constructor Bool :0 Type.

constructor True :10 Bool.

constructor False :5 Bool.

constructor Nat :6 Type.

constructor Z :12 Nat.

constructor S :9 (n :L Nat) -> Nat.

constructor Vect :11 (n :E Nat) -> Type.

constructor Nil :7 Vect Z.

constructor Cons :1 (n :I Nat) -> (x :L Bool) -> (xs :L Vect n) -> Vect (S n).

length :13 (n :14 Nat) -> (xs :15 Vect n) -> Nat {
  length {Z} Nil ~> Z
  forall (xs :19 Vect n) (x :21 Bool) (n :22 Nat).
    length ({S} n) (Cons [n] x xs) ~> S (length n xs)
}

main :L Nat {
  main ~> length (S Z) (Cons Z True Nil)
}

Running erasure inference...

########################
# Inferred constraints #
########################

Sums:
  I ≥ Sum
    product  [I]
    product  [I, 2]
    product  [I, 3, 4]
  E ≥ Sum
    product  [I]
  L ≥ Sum
    product  [I]
    product  [I]
    product  [I]
  0 ≥ Sum
    product  [I]
    product  [I]
    product  [I]
    product  [I]
  1 ≥ Sum
    product  [32]
  6 ≥ Sum
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
  7 ≥ Sum
    product  [32, 35]
  9 ≥ Sum
    product  [I, 3]
    product  []
    product  [33]
  10 ≥ Sum
    product  [32, 36]
  11 ≥ Sum
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
  12 ≥ Sum
    product  [I, 8]
    product  []
    product  [33, 34]
    product  [32, 37]
  13 ≥ Sum
    product  [29]
    product  []
  14 ≥ Sum
    product  [I]
    product  [I, 16]
  15 ≥ Sum
    product  [I]
  19 ≥ Sum
    product  [I]
    product  [29, 30]
  21 ≥ Sum
    product  [I]
    product  [I]
  22 ≥ Sum
    product  [I]
    product  [I]
    product  [I, 20]
    product  [I]
    product  [I]
    product  [29, 31]
  23 ≥ Sum
    product  [22]
  24 ≥ Sum
    product  [22]
  25 ≥ Sum
    product  [21]
    product  [19]
  27 ≥ Sum
    product  [21]
  28 ≥ Sum
    product  [19]

Maxes:
  I ≥ Max
    product  [26]
    product  [37]
  E ≥ Max
    product  [8]
    product  [2]
    product  [3]
    product  [16]
    product  [20]
  L ≥ Max
    product  [4]
    product  [24]
    product  [27]
    product  [28]
    product  [29]
    product  [34]
    product  [36]
    product  [35]
  1 ≥ Max
    product  [L, 13]
  2 ≥ Max
    product  [E]
    product  [20]
    product  [8]
  3 ≥ Max
    product  [E]
    product  [16]
    product  [16]
  4 ≥ Max
    product  [L]
  7 ≥ Max
    product  [L, 13]
  8 ≥ Max
    product  [E]
    product  [16]
    product  [2]
  14 ≥ Max
    product  [17]
    product  [23]
    product  [31]
    product  [33]
  15 ≥ Max
    product  [18]
    product  [25]
    product  [30]
    product  [32]
  16 ≥ Max
    product  [E]
    product  [8]
    product  [3]
    product  [20]
    product  [3]
  17 ≥ Max
    product  [14]
  18 ≥ Max
    product  [L]
    product  [15]
  20 ≥ Max
    product  [E]
    product  [2]
    product  [16]
  23 ≥ Max
    product  [14]
  24 ≥ Max
    product  [L]
  25 ≥ Max
    product  [L]
    product  [15]
  26 ≥ Max
    product  [I]
  27 ≥ Max
    product  [L]
  28 ≥ Max
    product  [L]
  29 ≥ Max
    product  [L]
  30 ≥ Max
    product  [15]
  31 ≥ Max
    product  [14]
  32 ≥ Max
    product  [15]
  33 ≥ Max
    product  [14]
  34 ≥ Max
    product  [L]
  35 ≥ Max
    product  [L]
  36 ≥ Max
    product  [L]
  37 ≥ Max
    product  [I]

#######################
# Deferred equalities #
#######################

8 -> Z ~ Z
20 -> n ~ n
3 -> S n ~ S n
20 -> n ~ n
8 -> Z ~ Z
3 -> S Z ~ S Z

  -> iteration 1
    Z ~ Z
    n ~ n
    S n ~ S n
    n ~ n
    Z ~ Z
    S Z ~ S Z

  -> iteration 2
    n ~ n
    Z ~ Z

  -> iteration 3
    -> No more equalities, fixed point reached.

###################
# Final valuation #
###################

  0 -> I
  1 -> L
  2 -> E
  3 -> E
  4 -> L
  6 -> I
  7 -> L
  8 -> E
  9 -> L
  10 -> L
  11 -> I
  12 -> L
  13 -> R
  14 -> I
  15 -> L
  16 -> E
  17 -> I
  18 -> L
  19 -> L
  20 -> E
  21 -> I
  22 -> I
  23 -> I
  24 -> L
  25 -> L
  26 -> I
  27 -> L
  28 -> L
  29 -> L
  30 -> L
  31 -> I
  32 -> L
  33 -> I
  34 -> L
  35 -> L
  36 -> L
  37 -> I

#####################
# Annotated program #
#####################

constructor Bool :I Type.

constructor True :L Bool.

constructor False :I Bool.

constructor Nat :I Type.

constructor Z :L Nat.

constructor S :L (n :L Nat) -> Nat.

constructor Vect :I (n :E Nat) -> Type.

constructor Nil :L Vect Z.

constructor Cons :L (n :I Nat) -> (x :L Bool) -> (xs :L Vect n) -> Vect (S n).

length :R (n :I Nat) -> (xs :L Vect n) -> Nat {
  length {Z} Nil ~> Z
  forall (xs :L Vect n) (x :I Bool) (n :I Nat).
    length ({S} n) (Cons [n] x xs) ~> S (length n xs)
}

main :L Nat {
  main ~> length (S Z) (Cons Z True Nil)
}

###############
# Final check #
###############

** OK **

##########
# Erased #
##########

constructor True : Bool.

constructor Z : Nat.

constructor S : (n) -> Nat.

constructor Nil : Vect.

constructor Cons : (x) -> (xs) -> Vect.

length : (xs) -> Nat {
  length Nil ~> Z
  forall (xs).
    length (Cons _ xs) ~> S (length xs)
}

main : Nat {
  main ~> length (Cons True Nil)
}

################
# NF of `main` #
################

Unerased, reduced:
S Z

Erased, reduced:
S Z
