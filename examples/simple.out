#############
# Desugared #
#############

constructor Bool : Type.

constructor True : Bool.

constructor False : Bool.

constructor T : Type.

constructor C : (pf :I Bool) -> T.

postulate U : (t :E T) -> Type.

postulate g : (x :L U (C True)) -> Bool.

postulate b : Bool.

postulate d : U (C b).

not : (x : Bool) -> Bool {
  not True ~> False
  not False ~> True
}

id : (a : Type) -> (x : a) -> a {
  forall (x : a) (a : Type).
    id a x ~> x
}

main :L Bool {
  main ~> (\x : U (C False). g x) d
}

#############
# Evarified #
#############

constructor Bool :0 Type.

constructor True :4 Bool.

constructor False :2 Bool.

constructor T :3 Type.

constructor C :1 (pf :I Bool) -> T.

postulate U :5 (t :E T) -> Type.

postulate g :10 (x :L U (C True)) -> Bool.

postulate b :6 Bool.

postulate d :7 U (C b).

not :25 (x :26 Bool) -> Bool {
  not True ~> False
  not False ~> True
}

id :13 (a :14 Type) -> (x :15 a) -> a {
  forall (x :16 a) (a :17 Type).
    id a x ~> x
}

main :L Bool {
  main ~> (\x :21 U (C False). g x) d
}

Running erasure inference...

########################
# Inferred constraints #
########################

Sums:
  I ≥ Sum
    product  [I]
  E ≥ Sum
    product  [I]
  L ≥ Sum
    product  [I]
  0 ≥ Sum
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
    product  [I]
  1 ≥ Sum
    product  [I, 11]
    product  [I, 8]
    product  [I, 22]
  2 ≥ Sum
    product  []
    product  [I, 22, 23]
  3 ≥ Sum
    product  [I]
    product  [I]
  4 ≥ Sum
    product  [I, 11, 12]
    product  []
  5 ≥ Sum
    product  [I]
    product  [I]
    product  [I]
  6 ≥ Sum
    product  [I, 8, 9]
  7 ≥ Sum
    product  [20]
  10 ≥ Sum
    product  []
  14 ≥ Sum
    product  [I]
    product  [I]
    product  [I]
  15 ≥ Sum
    product  [I]
  16 ≥ Sum
    product  [I]
    product  []
  17 ≥ Sum
    product  [I]
    product  [I]
    product  [I]
  18 ≥ Sum
    product  [17]
  19 ≥ Sum
    product  [16]
  21 ≥ Sum
    product  [I]
    product  [24]
  26 ≥ Sum
    product  [I]

Maxes:
  I ≥ Max
    product  [12]
    product  [9]
    product  [23]
  E ≥ Max
    product  [11]
    product  [8]
    product  [22]
  L ≥ Max
    product  [24]
  2 ≥ Max
    product  [L, 25]
  4 ≥ Max
    product  [L, 25]
  8 ≥ Max
    product  [E]
    product  [22]
  9 ≥ Max
    product  [I]
  11 ≥ Max
    product  [E]
    product  [22]
  12 ≥ Max
    product  [I]
  14 ≥ Max
    product  [18]
  15 ≥ Max
    product  [19]
  18 ≥ Max
    product  [14]
  19 ≥ Max
    product  [15]
  20 ≥ Max
    product  [21]
  21 ≥ Max
    product  [20]
  22 ≥ Max
    product  [E]
    product  [11]
    product  [8]
  23 ≥ Max
    product  [I]
  24 ≥ Max
    product  [L]
  26 ≥ Max
    product  [27]
    product  [28]
  27 ≥ Max
    product  [L]
    product  [26]
  28 ≥ Max
    product  [L]
    product  [26]

#######################
# Deferred equalities #
#######################

22 -> C False ~ C True
8 -> C b ~ C False

  -> iteration 1
    C False ~ C True
    C b ~ C False

  -> iteration 2
    -> No more equalities, fixed point reached.

###################
# Final valuation #
###################

  0 -> I
  1 -> I
  2 -> L
  3 -> I
  4 -> L
  5 -> I
  6 -> I
  7 -> L
  8 -> E
  9 -> I
  10 -> L
  11 -> E
  12 -> I
  14 -> I
  15 -> L
  16 -> L
  17 -> I
  18 -> I
  19 -> L
  20 -> L
  21 -> L
  22 -> E
  23 -> I
  24 -> L
  25 -> I
  26 -> L
  27 -> L
  28 -> L

#####################
# Annotated program #
#####################

constructor Bool :I Type.

constructor True :L Bool.

constructor False :L Bool.

constructor T :I Type.

constructor C :I (pf :I Bool) -> T.

postulate U :I (t :E T) -> Type.

postulate g :L (x :L U (C True)) -> Bool.

postulate b :I Bool.

postulate d :L U (C b).

not :I (x :L Bool) -> Bool {
  not True ~> False
  not False ~> True
}

id :I (a :I Type) -> (x :L a) -> a {
  forall (x :L a) (a :I Type).
    id a x ~> x
}

main :L Bool {
  main ~> (\x :L U (C False). g x) d
}

###############
# Final check #
###############

** OK **

##########
# Erased #
##########

constructor True : Bool.

constructor False : Bool.

postulate g : (x) -> Bool.

postulate d : U.

main : Bool {
  main ~> (\x. g x) d
}

################
# NF of `main` #
################

Unerased, reduced:
g d

Erased, reduced:
g d
